<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp</name>
    </assembly>
    <members>
        <member name="T:BaseItem">
            <summary>
            Basic implementation for the IItem interface
            </summary>
        </member>
        <member name="F:BaseItem.rotate">
            <summary>
            Enables the rotation of the item
            </summary>
        </member>
        <member name="F:BaseItem.rotationSpeed">
            <summary>
            The rotation speed of the item (angle the object rotates within a second in degree)
            </summary>
        </member>
        <member name="F:BaseItem.pickUpEffect">
            <summary>
            The effect to create when the object is picked up
            </summary>
        </member>
        <member name="F:BaseItem.fallPerSecond">
            <summary>
            How much the item falls per second (not quadratic, since item usually don't fall a lot
            </summary>
        </member>
        <member name="M:BaseItem.Start">
            <summary>
            Unity Start
            </summary>
        </member>
        <member name="M:BaseItem.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:BaseItem.FallDown">
            <summary>
            Lets the item fall (since the unity physics are somehow broken...)
            </summary>
        </member>
        <member name="M:BaseItem.DistanceToGround">
            <summary>
            Get the distance the entity is above something.
            </summary>
            <returns>The vertical distance to the next thing below the entity.</returns>
        </member>
        <member name="M:BaseItem.TurnIntoTrigger">
            <summary>
            Enables the trigger of the collider after a certain time
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:BaseItem.PickUp">
            <summary>
            Enables a game object to pick up another object
            </summary>
            <returns>The inventory id for the object</returns>
        </member>
        <member name="T:MovementManager">
            <summary>
            Manages automatic movement
            </summary>
        </member>
        <member name="T:Triggerable">
            <summary>
            this is an abstract class rather than an interface, so that in Unity a List of Triggerable
            will be displayed in the Inspector correctly so that it is possible to directly drag&amp;drop objects there
            </summary>
        </member>
        <member name="M:Triggerable.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            called by the trigger when it's activated
            </summary>
            <param name="by">by object</param>
            <param name="isTriggered">whether triggered</param>
        </member>
        <member name="F:MovementManager.actions">
            <summary>
            Actions to perform
            </summary>
        </member>
        <member name="F:MovementManager.running">
            <summary>
            Currently performed actions
            </summary>
        </member>
        <member name="F:MovementManager.pause">
            <summary>
            Variable indicating if the manager is paused
            </summary>
        </member>
        <member name="F:MovementManager.enable">
            <summary>
            True if the movement manager starts when triggered
            </summary>
        </member>
        <member name="F:MovementManager.isRun">
            <summary>
            Variable indicating if the cutscene is run
            </summary>
        </member>
        <member name="F:MovementManager.isLoop">
            <summary>
            Variable indicating if the cutscene is loop
            </summary>
        </member>
        <member name="F:MovementManager.bars">
            <summary>
            Texture of the black bars to display
            </summary>
        </member>
        <member name="F:MovementManager.positions">
            <summary>
            Saves the positions of the black bars
            </summary>
        </member>
        <member name="F:MovementManager.maxPosition">
            <summary>
            Saves the maximum position
            </summary>
        </member>
        <member name="F:MovementManager.initialPosition">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:MovementManager.ignoreCutscene">
            <summary>
            Enables scripts to disable the black bars
            </summary>
        </member>
        <member name="M:MovementManager.Awake">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:MovementManager.Start">
            <summary>
            Called when the Manager is created
            </summary>
        </member>
        <member name="M:MovementManager.StartManager">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="M:MovementManager.Update">
            <summary>
            Called every frame
            </summary>
        </member>
        <member name="M:MovementManager.Next">
            <summary>
            Runs the actions in the running list and copies new actions to it
            </summary>
        </member>
        <member name="M:MovementManager.RunCurrent">
            <summary>
            Run the Actions in the running list
            </summary>
        </member>
        <member name="M:MovementManager.ReadNext">
            <summary>
            Dequeue the next actions
            </summary>
        </member>
        <member name="M:MovementManager.RunCurrentGUI">
            <summary>
            Render the GUI actions
            </summary>
        </member>
        <member name="M:MovementManager.OnGUI">
            <summary>
            Called for the GUI
            </summary>
        </member>
        <member name="M:MovementManager.Append(IAction)">
            <summary>
            Appends a new IAction to the action queue
            </summary>
            <param name="action">The IAction to attach</param>
        </member>
        <member name="M:MovementManager.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Implementation of Triggerable
            </summary>
            <param name="by">Calling object (ignored)</param>
            <param name="isTriggered">The trigger is on</param>
        </member>
        <member name="M:MovementManager.Sleep(System.Single)">
            <summary>
            Convenience function for sleep
            </summary>
            <param name="seconds">Seconds to sleep</param>
        </member>
        <member name="M:MovementManager.Reset">
            <summary>
            adds a reset-action
            </summary>
        </member>
        <member name="M:MovementManager.Script">
            <summary>
            Script of the Cutscene
            </summary>
        </member>
        <member name="P:MovementManager.IsRunning">
            <summary>
            Returns if the Manager is running
            </summary>
        </member>
        <member name="T:AnimatedTexture">
            <summary>
            animate the main texture of the first material by animate offset and scale of the texture
            </summary>
        </member>
        <member name="F:AnimatedTexture.maxTextureSize">
            <summary>
            define the end of the scale animation 
            </summary>
        </member>
        <member name="F:AnimatedTexture.minTextureSize">
            <summary>
            define the start of the animation scale
            </summary>
        </member>
        <member name="F:AnimatedTexture.maxTextureOffsetX">
            <summary>
            define the end of the offset animation for x axe
            </summary>
        </member>
        <member name="F:AnimatedTexture.minTextureOffsetX">
            <summary>
            define the start of the offset animation for x axe
            </summary>
        </member>
        <member name="F:AnimatedTexture.maxTextureOffsetY">
            <summary>
            define the end of the offset animation for Y axe
            </summary>
        </member>
        <member name="F:AnimatedTexture.minTextureOffsetY">
            <summary>
            define the start of the offset animation for Y axe
            </summary>
        </member>
        <member name="F:AnimatedTexture.textureScaleSpeed">
            <summary>
            define the scale animation speed 
            </summary>
        </member>
        <member name="F:AnimatedTexture.textureOffsetSpeed">
            <summary>
            define the offset animation speed
            </summary>
        </member>
        <member name="F:AnimatedTexture.offsetX">
            <summary>
            current x offset
            </summary>
        </member>
        <member name="F:AnimatedTexture.offsetY">
            <summary>
            current y offset
            </summary>
        </member>
        <member name="F:AnimatedTexture.scale">
            <summary>
            current scale
            </summary>
        </member>
        <member name="M:AnimatedTexture.Start">
            <summary>
            start method
            </summary>
        </member>
        <member name="M:AnimatedTexture.Update">
            <summary>
            update method
            </summary>
        </member>
        <member name="T:BackgroundSound">
            <summary>
            Background sound manager.
            </summary>
        </member>
        <member name="F:BackgroundSound._instance">
            <summary>
            checking the instance
            </summary>
        </member>
        <member name="F:BackgroundSound.backgroundSongs">
            <summary>
            The list of all background songs.
            </summary>
        </member>
        <member name="F:BackgroundSound.currentTrack">
            <summary>
            current track
            </summary>
        </member>
        <member name="F:BackgroundSound.currentAudioClip">
            <summary>
            the current audio clip object
            </summary>
        </member>
        <member name="F:BackgroundSound.fadeIn">
            <summary>
            indicates whether a song is fading in
            </summary>
        </member>
        <member name="F:BackgroundSound.fadeOut">
            <summary>
            indicates whether a song is fading out
            </summary>
        </member>
        <member name="F:BackgroundSound.maxVolume">
            <summary>
            max volume to fade in
            </summary>
        </member>
        <member name="F:BackgroundSound.minVolume">
            <summary>
            min volume to fade out
            </summary>
        </member>
        <member name="F:BackgroundSound.volumeFadingStep">
            <summary>
            step size for volume fading
            </summary>
        </member>
        <member name="M:BackgroundSound.Awake">
            <summary>
            Called by Unity when constructing the game object.
            Prevent Game object from being destroyed when loading something new.
            </summary>
        </member>
        <member name="M:BackgroundSound.Start">
            <summary>
            Use this for initialization.
            </summary>
        </member>
        <member name="M:BackgroundSound.Update">
            <summary>
            Update is called once per frame.
            </summary>
        </member>
        <member name="M:BackgroundSound.FadeIn">
            <summary>
            start game background sound.
            </summary>
        </member>
        <member name="M:BackgroundSound.OnLevelWasLoaded(System.Int32)">
            <summary>
            loads new music list when new level is loaded
            </summary>
            <param name="level">index of the new level</param>
        </member>
        <member name="P:BackgroundSound.Instance">
            <summary>
            Return the Instance of our class.
            </summary>
        </member>
        <member name="T:CommonEntity">
            <summary>
            Contains common stuff for entities (e.g. player, enemies, etc..)
            </summary>
        </member>
        <member name="T:IHitable">
            <summary>
            interface for all hitable objects
            </summary>
        </member>
        <member name="M:IHitable.TakeDamage(System.Single)">
            <summary>
            Deals hp damage to the object
            </summary>
            <param name="hp">damage dealt</param>
        </member>
        <member name="M:IHitable.TakeDamageOverTime(System.Single,System.Single,System.Single)">
            <summary>
            Deals damage to the object over a period of time in a certain interval
            </summary>
            <param name="damagePerInterval">Damage dealt per interval</param>
            <param name="interval">Interval in which damage is dealt</param>
            <param name="seconds">Time until effect stops</param>
        </member>
        <member name="F:CommonEntity.currentState">
            <summary>
            Current state (e.g. being alive, dead, etc)
            </summary>
        </member>
        <member name="M:CommonEntity.IsDead">
            <summary>
            whether the object is dead and thus can not perform any actions
            </summary>
            <returns>whether dead</returns>
        </member>
        <member name="M:CommonEntity.IsAlive">
            <summary>
            we do what we must because we can
            </summary>
            <returns>if alive</returns>
        </member>
        <member name="F:CommonEntity.speed">
            <summary>
            speed of the enemy
            </summary>
        </member>
        <member name="M:CommonEntity.Start">
            <summary>
            Use this for initialization, HAS TO BE CALLED FROM SUBCLASSES!
            </summary>
        </member>
        <member name="M:CommonEntity.Update">
            <summary>
            HAS TO BE CALLED FROM SUBCLASSES!
            </summary>
        </member>
        <member name="M:CommonEntity.Die">
            <summary>
            Entity dies :(
            </summary>
        </member>
        <member name="F:CommonEntity.damageOverTimeEffects">
            <summary>
            Takes information about current damage over time effects
            </summary>
        </member>
        <member name="M:CommonEntity.TakeDamage(System.Single)">
            <summary>
            Deals hp damage to the object, see IHitable
            </summary>
            <param name="hp">damage dealt</param>
        </member>
        <member name="M:CommonEntity.TakeDamageOverTime(System.Single,System.Single,System.Single)">
            <summary>
            Deals damage to the object over a period of time in a certain interval, see IHitable
            </summary>
            <param name="damagePerInterval">Damage dealt per interval</param>
            <param name="interval">Interval in which damage is dealt</param>
            <param name="seconds">Time until effect stops</param>
        </member>
        <member name="M:CommonEntity.CalculateDamageOverTime">
            <summary>
            Calculates damage over time at e.g. every frame
            </summary>
        </member>
        <member name="F:CommonEntity.healthPoints">
            <summary>
            Current health points.
            
            If not set initially, it is set to maxHealthPoints
            </summary>
        </member>
        <member name="F:CommonEntity.maxHealthPoints">
            <summary>
            Maximum health points.
            
            If not set initially, it is set to 100
            </summary>
        </member>
        <member name="F:CommonEntity.healthRegeneration">
            <summary>
            Health regeneration OFF fight, per second
            
            If not set it defaults to 5
            </summary>
        </member>
        <member name="F:CommonEntity.timeUntilRegeneration">
            <summary>
            Time in seconds since last hit needed until regeneration
            
            If not set it defaults to 10
            </summary>
        </member>
        <member name="F:CommonEntity.lastHitTime">
            <summary>
            When did we get hit the last time? (Both direct hit and damage over time)
            </summary>
        </member>
        <member name="F:CommonEntity.lastAttackTime">
            <summary>
            When did we attack the last time?
            </summary>
        </member>
        <member name="M:CommonEntity.RegenerateHealth">
            <summary>
            Regenerate health in the set amount (usually out of fight)
            </summary>
        </member>
        <member name="M:CommonEntity.InstantaneousHeal(System.Single)">
            <summary>
            Heal entity
            </summary>
            <param name="hp">Amount to heal</param>
        </member>
        <member name="F:CommonEntity.mana">
            <summary>
            Energy used for jumping/shooting, etc
            
            set to maxMana, if unset
            </summary>
        </member>
        <member name="F:CommonEntity.maxMana">
            <summary>
            max mana
            
            Set to 100, if unset
            </summary>
        </member>
        <member name="F:CommonEntity.lastManaUsageTime">
            <summary>
            holds the time when mana is used last
            </summary>
        </member>
        <member name="F:CommonEntity.manaRegeneration">
            <summary>
            Mana regeneration  per second
            
            If not set it defaults to 10
            </summary>
        </member>
        <member name="F:CommonEntity.timeUntilManaRegeneration">
            <summary>
            Time in seconds since last mana usage needed until mana regeneration
            
            If not set it defaults to 10
            </summary>
        </member>
        <member name="M:CommonEntity.RegenerateMana">
            <summary>
            Regenerate mana in the set amount
            </summary>
        </member>
        <member name="M:CommonEntity.InstantaneousManaRegeneration(System.Single)">
            <summary>
            regenerate mana
            </summary>
            <param name="addMana">how much</param>
        </member>
        <member name="F:CommonEntity.distanceToGround">
            <summary>
            Distance to the lower bounding box.
            </summary>
        </member>
        <member name="M:CommonEntity.IsOnGround">
            <summary>
            Checks whether entity is currently standing on something solid.
            </summary>
            <returns>True if it's on the ground, else false.</returns>
        </member>
        <member name="M:CommonEntity.DistanceToGround">
            <summary>
            Get the distance the entity is above something.
            </summary>
            <returns>The vertical distance to the next thing below the entity.</returns>
        </member>
        <member name="M:CommonEntity.DistanceToRoof">
            <summary>
            Get the distance the entity is below something.
            </summary>
            <returns>The vertical distance to the next thing above the entity.</returns>
        </member>
        <member name="F:CommonEntity._lock">
            <summary>
            Our lock variable.
            </summary>
        </member>
        <member name="M:CommonEntity.IsLocked">
            <summary>
            Return true if entity is locke.
            </summary>
            <returns>True iff locked.</returns>
        </member>
        <member name="M:CommonEntity.Lock">
            <summary>
            Lock entity.
            </summary>
        </member>
        <member name="M:CommonEntity.Unlock">
            <summary>
            Unlock entity.
            </summary>
        </member>
        <member name="M:CommonEntity.StartAnimation(System.String)">
            <summary>
            Start animation with specific name.
            </summary>
            <param name="animation">the name of the animation.</param>
        </member>
        <member name="M:CommonEntity.GetAnimationLength(System.String)">
            <summary>
            Return the length of an animation.
            </summary>
            <param name="animation">The animation.</param>
            <returns>The length.</returns>
        </member>
        <member name="M:CommonEntity.IsHackable">
            <summary>
            Returns whether this entity can be hacked by the hacking skill.
            </summary>
            <returns>Always true.</returns>
        </member>
        <member name="F:CommonEntity.currentFaction">
            <summary>
            The faction of the enemy determines what objects are considered hostile. For enemies, this is usually Igor (or one of his friends). For Igor's friends, any "Enemy"-tagged unit is hostile
            NOTE: standard faction is assumed by different scripts to be ENEMY
            </summary>
        </member>
        <member name="M:CommonEntity.GetFaction">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
            <returns>the faction</returns>
        </member>
        <member name="M:CommonEntity.OnFactionChange">
            <summary>
            this function is called when a CommonEntity changes its faction
            use it for example to search for new targets..
            </summary>
        </member>
        <member name="M:CommonEntity.SetFaction(CommonEntity.Faction)">
            <summary>
            sets the current faction
            </summary>
            <param name="newFaction">new faction</param>
        </member>
        <member name="M:CommonEntity.ChangeFaction">
            <summary>
            changes the faction of the enemy
            </summary>
        </member>
        <member name="M:CommonEntity.IsFriend(CommonEntity)">
            <summary>
            checks whether the other object is considered a friend by this object
            </summary>
            <param name="other">to check</param>
            <returns>if friend</returns>
        </member>
        <member name="M:CommonEntity.IsFriend(CommonEntity.Faction)">
            <summary>
            returns whether the other faction is allied to this object
            </summary>
            <param name="otherFaction">to check</param>
            <returns>if friend</returns>
        </member>
        <member name="M:CommonEntity.FindNearestEnemy(System.Single,System.Single)">
            <summary>
            finds the nearest enemy matching the condition
            </summary>
            <param name="detectionRange">range to detect</param>
            <param name="angle">angle to detect</param>
            <returns>i just said that</returns>
        </member>
        <member name="T:CommonEntity.EntityState">
            <summary>
            the state of the entity
            there are several helper functions like IsAlive and IsDead for convenience
            </summary>
        </member>
        <member name="F:CommonEntity.EntityState.dead">
            <summary>
            Entity is dead.
            </summary>
        </member>
        <member name="F:CommonEntity.EntityState.normal">
            <summary>
            Usual state: Moving around, etc.
            </summary>
        </member>
        <member name="F:CommonEntity.EntityState.startpushing">
            <summary>
            (start)state when pushing/pulling boxes around
            </summary>
        </member>
        <member name="F:CommonEntity.EntityState.pushing">
            <summary>
            actual push
            </summary>
        </member>
        <member name="T:CommonEntity.DamageOverTime">
            <summary>
            Saves on effect of damage over time
            </summary>
        </member>
        <member name="F:CommonEntity.DamageOverTime.lastTime">
            <summary>
            Last time (in seconds) since the damage happened
            </summary>
        </member>
        <member name="F:CommonEntity.DamageOverTime.damagePerInterval">
            <summary>
            Damage taken
            </summary>
        </member>
        <member name="F:CommonEntity.DamageOverTime.interval">
            <summary>
            interval of dot
            </summary>
        </member>
        <member name="F:CommonEntity.DamageOverTime.timeLeft">
            <summary>
            time left
            </summary>
        </member>
        <member name="T:CommonEntity.Faction">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:CommonEntity.Faction.NONE">
            <summary>
            No faction (neutral).
            </summary>
        </member>
        <member name="F:CommonEntity.Faction.PLAYER">
            <summary>
            Plays with the player.
            </summary>
        </member>
        <member name="F:CommonEntity.Faction.ENEMY">
            <summary>
            Plays against the player.
            </summary>
        </member>
        <member name="T:Credits">
            <summary>
            Shows the credits
            </summary>
        </member>
        <member name="F:Credits.renderSizeX">
            <summary>
            internal render size
            </summary>
        </member>
        <member name="F:Credits.renderSizeY">
            <summary>
            internal render size
            </summary>
        </member>
        <member name="F:Credits.img">
            <summary>
            Image used as background
            </summary>
        </member>
        <member name="F:Credits.blackPixel">
            <summary>
            back texture
            </summary>
        </member>
        <member name="F:Credits.tex01IgorChronicles">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex02Design">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex03Design">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex04Proj">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex05Proj">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex06Devel">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex07Devel">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex08Artists">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex09Artists">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex10Alpha">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex11Alpha">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex12Beta">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex13Beta">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex14SpecialThanks">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex15SpecialThanks">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex16SpecialThanks">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex17RobotHarming">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex18Draph">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex19Draph">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.tex20Draph">
            <summary>
            Tex to show
            </summary>
        </member>
        <member name="F:Credits.currentImg">
            <summary>
            Current image
            </summary>
        </member>
        <member name="F:Credits.currentImgTime">
            <summary>
            Time in the current image
            </summary>
        </member>
        <member name="F:Credits.effectTimePerImage">
            <summary>
            Time for the effect of one image
            </summary>
        </member>
        <member name="F:Credits.timePerImg">
            <summary>
            Time for one image
            </summary>
        </member>
        <member name="F:Credits.pixelToDo">
            <summary>
            Pixel to do (used at various effects)
            </summary>
        </member>
        <member name="F:Credits.pixelPos">
            <summary>
            Current position
            </summary>
        </member>
        <member name="M:Credits.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:Credits.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:Credits.EndScene">
            <summary>
            Return to e.g. main menu
            </summary>
        </member>
        <member name="M:Credits.OnGUI">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:Credits.GeneratePixelToDo">
            <summary>
            Generate PixelToDo
            </summary>
        </member>
        <member name="M:Credits.EffectPixelFlip(UnityEngine.Texture2D)">
            <summary>
            Flips the pixel time after time
            </summary>
            <param name="otherImg">credit image to flip to</param>
        </member>
        <member name="T:Credits.Coords">
            <summary>
            Coordinates of a pixel
            </summary>
        </member>
        <member name="F:Credits.Coords.x">
            <summary>
            x coordinate
            </summary>
        </member>
        <member name="F:Credits.Coords.y">
            <summary>
            y coordinate
            </summary>
        </member>
        <member name="T:IntroCutscene">
            <summary>
            the infamous intro cutscene class
            </summary>
        </member>
        <member name="F:IntroCutscene.text1">
            <summary>
            Reference to the connection text
            </summary>
        </member>
        <member name="F:IntroCutscene.text2">
            <summary>
            Reference to the connected text
            </summary>
        </member>
        <member name="F:IntroCutscene.usedCamera">
            <summary>
            Reference to the camera
            </summary>
        </member>
        <member name="F:IntroCutscene.cameraTarget">
            <summary>
            Camera target
            </summary>
        </member>
        <member name="F:IntroCutscene.gil">
            <summary>
            Reference to Gil
            </summary>
        </member>
        <member name="F:IntroCutscene.igor">
            <summary>
            Reference to Igor
            </summary>
        </member>
        <member name="F:IntroCutscene.jeve">
            <summary>
            Reference to Jeve
            </summary>
        </member>
        <member name="M:IntroCutscene.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:JeveAndIgor">
            <summary>
            cut scenes for level 0.4 which shows pictures
            </summary>
        </member>
        <member name="F:JeveAndIgor.pictures">
            <summary>
            pictures which will be shown
            </summary>
        </member>
        <member name="M:JeveAndIgor.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:JeveDie">
            <summary>
            the cutscene of Jeve's HORRIBLE DEATH
            </summary>
        </member>
        <member name="F:JeveDie.spark">
            <summary>
            spark which will spawn on the console
            </summary>
        </member>
        <member name="F:JeveDie.hitEffect">
            <summary>
            hit which will spawn on the console when igor attack it
            </summary>
        </member>
        <member name="F:JeveDie.jeveDead">
            <summary>
            reference to explosion
            </summary>
        </member>
        <member name="F:JeveDie.explosion">
            <summary>
            reference to explosion
            </summary>
        </member>
        <member name="F:JeveDie.cam">
            <summary>
            reference to camera
            </summary>
        </member>
        <member name="F:JeveDie.siren">
            <summary>
            reference to siren
            </summary>
        </member>
        <member name="F:JeveDie.enemyText4">
            <summary>
            reference to Fatal Error text
            </summary>
        </member>
        <member name="F:JeveDie.enemyText3">
            <summary>
            reference to Fatal Error text
            </summary>
        </member>
        <member name="F:JeveDie.enemyText2">
            <summary>
            reference to Fatal Error text
            </summary>
        </member>
        <member name="F:JeveDie.enemyText1">
            <summary>
            reference to Fatal Error text
            </summary>
        </member>
        <member name="F:JeveDie.fatalError">
            <summary>
            reference to Fatal Error text
            </summary>
        </member>
        <member name="F:JeveDie.booting">
            <summary>
            reference to booting text
            </summary>
        </member>
        <member name="F:JeveDie.errorScreen">
            <summary>
            error screen 
            </summary>
        </member>
        <member name="F:JeveDie.robot">
            <summary>
            reference to Diagnostic Robot
            </summary>
        </member>
        <member name="F:JeveDie.igor">
            <summary>
            reference to Gill
            </summary>
        </member>
        <member name="F:JeveDie.jeve">
            <summary>
            reference to Jeve
            </summary>
        </member>
        <member name="M:JeveDie.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:LeaveLevel1">
            <summary>
            Cut scene when leaving first level
            </summary>
        </member>
        <member name="F:LeaveLevel1.igor">
            <summary>
            reference to igor
            </summary>
        </member>
        <member name="F:LeaveLevel1.console">
            <summary>
            reference to console
            </summary>
        </member>
        <member name="M:LeaveLevel1.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:IgorLeaveEnemyTest">
            <summary>
            Script to allow/disallow to leave Igor the enemy test in the tutorial level
            </summary>
        </member>
        <member name="F:IgorLeaveEnemyTest.useItems">
            <summary>
            items which are must pick up before the scene start
            </summary>
        </member>
        <member name="F:IgorLeaveEnemyTest.TriggerEnable">
            <summary>
            trigger which is enabled
            </summary>
        </member>
        <member name="F:IgorLeaveEnemyTest.igor">
            <summary>
            reference to igor
            </summary>
        </member>
        <member name="F:IgorLeaveEnemyTest.jeve">
            <summary>
            reference to Jeve
            </summary>
        </member>
        <member name="F:IgorLeaveEnemyTest.run">
            <summary>
            flag which will be set by the first play to prepare scene that it is running only one time
            </summary>
        </member>
        <member name="F:IgorLeaveEnemyTest.skilTutorialDone">
            <summary>
            flag for skill tutorial only once 
            </summary>
        </member>
        <member name="M:IgorLeaveEnemyTest.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:IgorLeaveIgorMaker">
            <summary>
            Igor leaves the igor maker - easy as that :D
            </summary>
        </member>
        <member name="F:IgorLeaveIgorMaker.jeve">
            <summary>
            reference to Jeve
            </summary>
        </member>
        <member name="M:IgorLeaveIgorMaker.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:IgorLeaveJump">
            <summary>
            some random cutscene
            </summary>
        </member>
        <member name="F:IgorLeaveJump.igor">
            <summary>
            reference to igor
            </summary>
        </member>
        <member name="F:IgorLeaveJump.jeve">
            <summary>
            reference to Jeve
            </summary>
        </member>
        <member name="F:IgorLeaveJump.done">
            <summary>
            flag which will be set by the first play to prepare scene that it is running only one time
            </summary>
        </member>
        <member name="F:IgorLeaveJump.run">
            <summary>
            a variable
            </summary>
        </member>
        <member name="M:IgorLeaveJump.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:IgorLeaveTutorial">
            <summary>
            last cut scene in the tutorial
            </summary>
        </member>
        <member name="F:IgorLeaveTutorial.useItems">
            <summary>
            items which are must pick up before the scene start
            </summary>
        </member>
        <member name="F:IgorLeaveTutorial.igor">
            <summary>
            reference to igor
            </summary>
        </member>
        <member name="F:IgorLeaveTutorial.jeve">
            <summary>
            reference to Jeve
            </summary>
        </member>
        <member name="M:IgorLeaveTutorial.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:IgotLeaveItemTest">
            <summary>
            leave item test area in the tutorial level
            </summary>
        </member>
        <member name="F:IgotLeaveItemTest.useItems">
            <summary>
            items which are must pick up before the scene start
            </summary>
        </member>
        <member name="F:IgotLeaveItemTest.TriggerEnable">
            <summary>
            trigger witch is enabled
            </summary>
        </member>
        <member name="F:IgotLeaveItemTest.igor">
            <summary>
            reference to igor
            </summary>
        </member>
        <member name="F:IgotLeaveItemTest.jeve">
            <summary>
            reference to Jeve
            </summary>
        </member>
        <member name="F:IgotLeaveItemTest.run">
            <summary>
            flag which will be set by the first play to prepare scene that it is running only one time
            </summary>
        </member>
        <member name="M:IgotLeaveItemTest.Script">
            <summary>
            cutscene script
            </summary>
        </member>
        <member name="T:DropChest">
            <summary>
            Animate a item by leaving a chest
            </summary>
        </member>
        <member name="F:DropChest.direction">
            <summary>
            direction in which the item will move after leaving the box
            </summary>
        </member>
        <member name="F:DropChest.currentDirection">
            <summary>
            current direction of the move
            </summary>
        </member>
        <member name="F:DropChest.scale">
            <summary>
            start scale of the animation
            </summary>
        </member>
        <member name="F:DropChest.maxScale">
            <summary>
            end scale of the animation
            </summary>
        </member>
        <member name="M:DropChest.Start">
            <summary>
            unity default function
            </summary>
        </member>
        <member name="M:DropChest.Update">
            <summary>
            unity default function
            </summary>
        </member>
        <member name="M:DropChest.ItemDrop">
            <summary>
            delay function for the forward movement (waiting to reach the chest  border before moving out)
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:Lightning">
            <summary>
            Lightning effect. Can be used on empty game objects to create lightning stroke.
            </summary>
        </member>
        <member name="F:Lightning.fromTransform">
            <summary>
            Where do we start the lightning?
            </summary>
            <remarks>Iff this is null we will use fromPosition as a static start point.</remarks>
        </member>
        <member name="F:Lightning.fromPosition">
            <summary>
            Iff fromTransform is null this is the static position. Otherwise this is a translation from fromTransform.
            </summary>
        </member>
        <member name="F:Lightning.toTransform">
            <summary>
            See fromTransform.
            </summary>
        </member>
        <member name="F:Lightning.toPosition">
            <summary>
            See fromPosition.
            </summary>
        </member>
        <member name="F:Lightning.intermediatePoints">
            <summary>
            How many points should be inserted between beginning and end?
            </summary>
        </member>
        <member name="F:Lightning.material">
            <summary>
            The material to use.
            </summary>
        </member>
        <member name="F:Lightning.lineRenderer">
            <summary>
            The line renderer of the corresponding game object.
            </summary>
        </member>
        <member name="F:Lightning.points">
            <summary>
            All points which define the line renderer.
            </summary>
        </member>
        <member name="F:Lightning.speed">
            <summary>
            How fast does the lightning move?
            </summary>
        </member>
        <member name="F:Lightning.randomRange">
            <summary>
            How much do the bending points move randomly?
            </summary>
        </member>
        <member name="M:Lightning.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Lightning.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="M:Lightning.OnDisable">
            <summary>
            Called when this component is disabled.
            </summary>
        </member>
        <member name="M:Lightning.OnEnable">
            <summary>
            Called when this component is enabled.
            </summary>
        </member>
        <member name="T:BossAI">
            <summary>
            Ai for the boss enemy
            </summary>
        </member>
        <member name="T:EnemyAI">
            <summary>
            generic AI helpers
            </summary>
        </member>
        <member name="F:EnemyAI.type">
            <summary>
            the type of enemy
            </summary>
        </member>
        <member name="F:EnemyAI.NavMeshTransforms">
            <summary>
            The waypoints array
            </summary>
        </member>
        <member name="F:EnemyAI.NavMeshTransformsPosition">
            <summary>
            position array for save game
            </summary>
        </member>
        <member name="F:EnemyAI.detectionRange">
            <summary>
            radius the player needs to be within to be detected by enemy
            </summary>
        </member>
        <member name="F:EnemyAI.followingRange">
            <summary>
            radius the player needs to be within to be followed by the enemy
            (followingRange > detectionRange)
            </summary>
        </member>
        <member name="F:EnemyAI.rangeEnemyMaxVerticalSightAngle">
            <summary>
            the max vertical sight angle that a range enemy can see
            </summary>
        </member>
        <member name="F:EnemyAI.meleeEnemyMaxVerticalSightAngle">
            <summary>
            the max vertical sight angle that a melee enemy can see
            </summary>
        </member>
        <member name="F:EnemyAI.rangeAttackRange">
            <summary>
            the max range that range enemy will take a attack
            </summary>
        </member>
        <member name="F:EnemyAI.viewAngle">
            <summary>
            view angle for enemy
            </summary>
        </member>
        <member name="F:EnemyAI.nma">
            <summary>
            Navigation mesh agent
            </summary>
        </member>
        <member name="F:EnemyAI.currentWaypoint">
            <summary>
            The i-st waypoint
            </summary>
        </member>
        <member name="F:EnemyAI.posOrNega">
            <summary>
            direction of Patrol
            true = positive
            false = negative
            </summary>
        </member>
        <member name="F:EnemyAI.isPatrolling">
            <summary>
            whether patrolling is allowed
            </summary>
        </member>
        <member name="F:EnemyAI.isEscape">
            <summary>
            If enemy run away
            </summary>
        </member>
        <member name="F:EnemyAI.isCurrentlyFollowing">
            <summary>
            whether the enemy needs to return to the path after following finished (player out of sight)
            </summary>
        </member>
        <member name="F:EnemyAI.escapeStep">
            <summary>
            step of the current escape
            </summary>
        </member>
        <member name="F:EnemyAI.escapeReturnPoint">
            <summary>
            point to return to after a successful escape
            </summary>
        </member>
        <member name="F:EnemyAI.timeToDestruction">
            <summary>
            time the robot needs to explode after death
            </summary>
        </member>
        <member name="F:EnemyAI.isloaded">
            <summary>
            whether the enemy is a instance that instantiated in loading game
            </summary>
        </member>
        <member name="M:EnemyAI.ExecuteEscape(System.Single,System.Single)">
            <summary>
            starts an escape for "seconds" with the velocity of "speed"
            </summary>
            <param name="seconds">in seconds</param>
            <param name="speed">the speed</param>
        </member>
        <member name="M:EnemyAI.StopEscape">
            <summary>
            stops the current escape
            </summary>
        </member>
        <member name="M:EnemyAI.ExecutePatroling(System.Boolean)">
            <summary>
            controls whether the patrol logic is active
            </summary>
            <param name="whetherToActivate">some parameter</param>
        </member>
        <member name="M:EnemyAI.Die">
            <summary>
            called on Death of the AI
            </summary>
        </member>
        <member name="M:EnemyAI.Destruct">
            <summary>
            destruction directive of the enemy
            </summary>
        </member>
        <member name="M:EnemyAI.OnMeleeAttack(UnityEngine.GameObject)">
            <summary>
            called when the enemy is in melee range and executes an attack
            </summary>
            <param name="player">the player</param>
        </member>
        <member name="M:EnemyAI.Start">
            <summary>
            Unity Start
            </summary>
        </member>
        <member name="M:EnemyAI.Update">
            <summary>
            Unity Update
            </summary>
        </member>
        <member name="F:EnemyAI.hasCustomDestination">
            <summary>
            if the enemy has a custom destination, it will not follow the player etc until that destination was reached
            </summary>
        </member>
        <member name="M:EnemyAI.SetCustomDestination(UnityEngine.Vector3)">
            <summary>
            sets a custom destination for the navigation mesh agent, a callback will be called once the destination has been reached
            </summary>
            <param name="destination">the destination</param>
        </member>
        <member name="M:EnemyAI.CheckCustomDestination">
            <summary>
            behavior that is executed when the enemy has reached a custom destination
            </summary>
            <returns>whether no other behavior allowed at the moment</returns>
        </member>
        <member name="M:EnemyAI.OnCustomDestinationReached">
            <summary>
            this callback is called once the enemy has reached a custom destination
            </summary>
        </member>
        <member name="M:EnemyAI.InWayPoint">
            <summary>
            indicates whether enemy is in the way point
            </summary>
            <returns>if in way point</returns>
        </member>
        <member name="M:EnemyAI.OrdinalPatrol">
            <summary>
             The object move ordinal from a waypoint to another waypoint
            </summary>
        </member>
        <member name="M:EnemyAI.RandomPatrol">
            <summary>
            The object move randomly from a waypoint to another waypoint
            </summary>
        </member>
        <member name="M:EnemyAI.ReturnToRandomWaypoint">
            <summary>
            The enemy return to a random way point
            </summary>
        </member>
        <member name="M:EnemyAI.ReturnToNearWaypoint">
            <summary>
            The enemy return to the nearest way point
            </summary>
        </member>
        <member name="M:EnemyAI.StopPatrol">
            <summary>
            enemy stop patrol
            </summary>
        </member>
        <member name="F:EnemyAI.blindFollowingEnabled">
            <summary>
            when enabled, the AI will still follow its target even if it is not in sight
            </summary>
        </member>
        <member name="M:EnemyAI.EnableBlindFollowing(System.Boolean)">
            <summary>
            enables or disables blind following
            </summary>
            <param name="whether">if enabled</param>
        </member>
        <member name="M:EnemyAI.PlayerInSight">
            <summary>
            indicates whether the player in the sight of enemy
            The sight area is a fan shape which defined by @detectionRange and @viewAngle
            </summary>
            <returns>if in sight</returns>
        </member>
        <member name="M:EnemyAI.EnemyEscape">
            <summary>
            enemy escape from battle,run toward the opposite direction of player and stop 
            </summary>
        </member>
        <member name="M:EnemyAI.EnemyFollow">
            <summary>
            enemy follow player
            </summary>
        </member>
        <member name="M:EnemyAI.StopFollow">
            <summary>
            enemy stop follow player
            </summary>
        </member>
        <member name="M:EnemyAI.LookAtPlayer">
            <summary>
            change the rotation to face the player
            </summary>
        </member>
        <member name="M:EnemyAI.RotateToBehind">
            <summary>
            the enemy move to behind of player
            </summary>
        </member>
        <member name="M:EnemyAI.GetDistanceBetweenEnemyAndPlayer">
            <summary>
            get the distance between enemy and player
            </summary>
            <returns>the distance</returns>
        </member>
        <member name="M:EnemyAI.GetVerticalAngleBetweenEnemyAndPlayer">
            <summary>
            returns the angle
            </summary>
            <returns>some angle</returns>
        </member>
        <member name="M:EnemyAI.GetVerticalAngleBetweenObjectAndTarget(UnityEngine.Vector3)">
            <summary>
            Get Vertical Angle Between Object And Target
            </summary>
            <param name="objectPosition">object position</param>
            <returns>vertical angle between input object and currentTarget</returns>
        </member>
        <member name="F:EnemyAI.meleeAttackRadius">
            <summary>
            melee attack area
            </summary>
        </member>
        <member name="F:EnemyAI.meleeAttackAngle">
            <summary>
            melee attack area
            </summary>
        </member>
        <member name="F:EnemyAI.meleeAttackCurrentCooldown">
            <summary>
            current cooldown of the melee attack
            </summary>
        </member>
        <member name="M:EnemyAI.StartMeleeAttackCooldown(System.Int32)">
            <summary>
            OnMeleeAttack will not be called for "seconds" seconds
            </summary>
            <param name="seconds">the seconds</param>
        </member>
        <member name="M:EnemyAI.DecreaseMeleeAttackCooldown">
            <summary>
            decreases the melee attack cooldown by 1 every second
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:EnemyAI.InMeleeAttackRange(System.Boolean,System.Single)">
            <summary>
            test if the enemy should take a attack
            </summary>
            <param name="ignoreAngle">whether to ignore the angle</param>
            <param name="rangeFactor">scale the view range</param>
            <returns>if in range</returns>
        </member>
        <member name="M:EnemyAI.InBattleMode(System.Single)">
            <summary>
             whether enemy in battle mode
            </summary>
            <param name="battleDistance">if the distance between enemy and player then in to the battle mode</param>
            <returns>in the battle mode return true ;else return false</returns>
        </member>
        <member name="F:EnemyAI.rangeAttackCurrentCooldown">
            <summary>
            remaining cooldown of attack in seconds
            </summary>
        </member>
        <member name="M:EnemyAI.StartRangeAttackCooldown(System.Single)">
            <summary>
            ranged attack will not execute while on cooldown
            </summary>
            <param name="seconds">for seconds</param>
        </member>
        <member name="M:EnemyAI.OnRangeAttack">
            <summary>
            will be called when the enemy is ready for a ranged attack and in sight
            </summary>
        </member>
        <member name="M:EnemyAI.OnFactionChange">
            <summary>
            on a faction change, refresh the target
            </summary>
        </member>
        <member name="F:EnemyAI.currentTarget">
            <summary>
            the CommonEntity which is the current target of this enemy
            </summary>
        </member>
        <member name="M:EnemyAI.GetCurrentTarget">
            <summary>
            currently targeted by this enemy
            </summary>
            <returns>the target</returns>
        </member>
        <member name="M:EnemyAI.CheckTarget">
            <summary>
            possibly refreshes the current target
            </summary>
        </member>
        <member name="M:EnemyAI.FindNewTarget">
            <summary>
            looks for a new target
            </summary>
        </member>
        <member name="T:EnemyAI.EnemyTpye">
            <summary>
            enum for definition enemy type
            </summary>
        </member>
        <member name="F:EnemyAI.EnemyTpye.Melee">
            <summary>
            Enemy only has a melee attack.
            </summary>
        </member>
        <member name="F:EnemyAI.EnemyTpye.Range">
            <summary>
            Enemy only has a range attack.
            </summary>
        </member>
        <member name="F:BossAI.door">
            <summary>
            exit door
            </summary>
        </member>
        <member name="F:BossAI.run">
            <summary>
            activate the movement and attack
            </summary>
        </member>
        <member name="F:BossAI.transformer">
            <summary>
            transformer on which the Boss load his live
            </summary>
        </member>
        <member name="F:BossAI.shield">
            <summary>
            shield of the boss
            </summary>
        </member>
        <member name="F:BossAI.animator">
            <summary>
            animator of the boss model
            </summary>
        </member>
        <member name="F:BossAI.rangeProjektile">
            <summary>
            prefab of the boss rocket
            </summary>
        </member>
        <member name="F:BossAI.projektileStartPoint">
            <summary>
            transform which will used by for the start position of the range projectile
            </summary>
        </member>
        <member name="F:BossAI.lastPosition">
            <summary>
            the position from the last  update
            </summary>
        </member>
        <member name="F:BossAI.rangeAtackCooldown">
            <summary>
            time to the next ranged attack
            </summary>
        </member>
        <member name="F:BossAI.curentRangeAtackCooldown">
            <summary>
            current time to the next range attack
            </summary>
        </member>
        <member name="F:BossAI.rangAnimationDelay">
            <summary>
            delay for waiting of the animation before we instanciate the rocket of the ranged attack
            </summary>
        </member>
        <member name="F:BossAI.charge">
            <summary>
            texture for the health bar background
            </summary>
        </member>
        <member name="F:BossAI.chargeSpeed">
            <summary>
            speed in which the boss charges on transformers
            </summary>
        </member>
        <member name="F:BossAI.healthBarTexture">
            <summary>
            Texture for healthBar
            </summary>
        </member>
        <member name="F:BossAI.barBackgroundTexture">
            <summary>
            Texture for the background of the health bar
            </summary>
        </member>
        <member name="F:BossAI.skillPointMessageguiStyle">
            <summary>
            How to draw the skill point message
            </summary>
        </member>
        <member name="M:BossAI.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:BossAI.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:BossAI.TakeDamage(System.Single)">
            <summary>
            Let's the boss take damage
            </summary>
            <param name="hp">Amount of damage to deal</param>
        </member>
        <member name="M:BossAI.RangeAttack">
            <summary>
            Activate rocket after 1 second 
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:BossAI.ResetUpdate">
            <summary>
            reset base.Update transform changes cause of base.update must be calculate all the time
            </summary>
        </member>
        <member name="M:BossAI.StartAnimation(System.String)">
            <summary>
            Start animation with specific name.
            </summary>
            <param name="animation">the name of the animation.</param>
        </member>
        <member name="M:BossAI.GetAnimationLength(System.String)">
            <summary>
            Return the length of an animation.
            </summary>
            <param name="animation">The animation.</param>
            <returns>The length.</returns>
        </member>
        <member name="M:BossAI.IsHackable">
            <summary>
            Returns whether this entity can be hacked by the hacking skill.
            </summary>
            <returns>Always false.</returns>
        </member>
        <member name="M:BossAI.OnGUI">
            <summary>
            draw boss health bar
            </summary>
        </member>
        <member name="M:BossAI.UnityStart_GUI">
            <summary>
            Called by the Unity Start() method. Extracted for better readability.
            </summary>
        </member>
        <member name="T:BossRocket">
            <summary>
            rocket of the boss enemy
            </summary>
        </member>
        <member name="F:BossRocket.damage">
            <summary>
            damage which the colliding object will take 
            </summary>
        </member>
        <member name="F:BossRocket.speed">
            <summary>
            speed of the Rocket
            </summary>
        </member>
        <member name="F:BossRocket.hitEffect">
            <summary>
            effect which will played by a hit
            </summary>
        </member>
        <member name="F:BossRocket.moveDirection">
            <summary>
            current move direction
            </summary>
        </member>
        <member name="M:BossRocket.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:BossRocket.Update">
            <summary>
            Standard Unity
            </summary>
        </member>
        <member name="M:BossRocket.OnCollisionEnter(UnityEngine.Collision)">
            <summary>
            instanciate explosion by collision
            </summary>
            <param name="collision">object with which the rocket collide</param>
        </member>
        <member name="T:Transformer">
            <summary>
            some random transformer class used in the boss fight, but can be hit
            </summary>
        </member>
        <member name="F:Transformer.animator">
            <summary>
            reference to Animator
            </summary>
        </member>
        <member name="M:Transformer.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Transformer.Update">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Transformer.Die">
            <summary>
            When Igor dies we play the die animation and disable the jetpack.
            </summary>
        </member>
        <member name="T:ArmEnemy">
            <summary>
            Stationary arm enemy
            </summary>
        </member>
        <member name="F:ArmEnemy.meleeAttackDamage">
            <summary>
            the damage
            </summary>
        </member>
        <member name="F:ArmEnemy.animator">
            <summary>
            reference to the animator
            </summary>
        </member>
        <member name="F:ArmEnemy.viewRange">
            <summary>
            range in which the arm reacts to Igor
            </summary>
        </member>
        <member name="F:ArmEnemy.attackRange">
            <summary>
            range in which the arm attacks Igor
            </summary>
        </member>
        <member name="F:ArmEnemy.inAttack">
            <summary>
            flag for the attack which is currently running
            </summary>
        </member>
        <member name="F:ArmEnemy.attack1Cooldown">
            <summary>
            cooldown for attack 1
            </summary>
        </member>
        <member name="F:ArmEnemy.attack2Cooldown">
            <summary>
            cooldown for attack 2
            </summary>
        </member>
        <member name="F:ArmEnemy.explosionPrefab">
            <summary>
            explosion prefab
            </summary>
        </member>
        <member name="F:ArmEnemy.smoke">
            <summary>
            instance of the smoke prefab when robot died
            </summary>
        </member>
        <member name="F:ArmEnemy.smokePrefab">
            <summary>
            smoke prefab
            </summary>
        </member>
        <member name="M:ArmEnemy.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:ArmEnemy.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:ArmEnemy.Attack1CooldownAnimation">
            <summary>
            Calculate Animation And Damage
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:ArmEnemy.Die">
            <summary>
            die die die die
            </summary>
        </member>
        <member name="M:ArmEnemy.Destruct">
            <summary>
            execute destruction
            </summary>
        </member>
        <member name="T:DiagnosisRobotEnemy">
            <summary>
            the infamous janitor
            </summary>
        </member>
        <member name="F:DiagnosisRobotEnemy.meleeDamage">
            <summary>
            base melee attack damage
            </summary>
        </member>
        <member name="F:DiagnosisRobotEnemy.smokePrefab">
            <summary>
            smoke prefab
            </summary>
        </member>
        <member name="F:DiagnosisRobotEnemy.explosionPrefab">
            <summary>
            explosion prefab
            </summary>
        </member>
        <member name="F:DiagnosisRobotEnemy.smoke">
            <summary>
            instance of the smoke prefab when robot died
            </summary>
        </member>
        <member name="F:DiagnosisRobotEnemy.peepSound">
            <summary>
            the peep sound when dead
            </summary>
        </member>
        <member name="M:DiagnosisRobotEnemy.Start">
            <summary>
            initial start method
            </summary>
        </member>
        <member name="M:DiagnosisRobotEnemy.Update">
            <summary>
            Update method
            </summary>
        </member>
        <member name="M:DiagnosisRobotEnemy.OnMeleeAttack(UnityEngine.GameObject)">
            <summary>
            called when the enemy is in melee range and executes an attack
            </summary>
            <param name="player">a player</param>
        </member>
        <member name="M:DiagnosisRobotEnemy.TakeDamage(System.Single)">
            <summary>
            takes the damage of
            </summary>
            <param name="hp">amount of hp taken</param>
        </member>
        <member name="M:DiagnosisRobotEnemy.Die">
            <summary>
            die method
            </summary>
        </member>
        <member name="M:DiagnosisRobotEnemy.Destruct">
            <summary>
            callback by common entity
            </summary>
        </member>
        <member name="T:FlyingEyeEnemy">
            <summary>
            big brother's here
            </summary>
        </member>
        <member name="F:FlyingEyeEnemy.meleeDamage">
            <summary>
            base melee attack damage
            </summary>
        </member>
        <member name="F:FlyingEyeEnemy.explosionPrefab">
            <summary>
            explosion prefab
            </summary>
        </member>
        <member name="F:FlyingEyeEnemy.animator">
            <summary>
            internal use
            </summary>
        </member>
        <member name="M:FlyingEyeEnemy.Start">
            <summary>
            initial start method
            </summary>
        </member>
        <member name="F:FlyingEyeEnemy.lastPosition">
            <summary>
            to set the right animation
            </summary>
        </member>
        <member name="M:FlyingEyeEnemy.Update">
            <summary>
            Update method
            </summary>
        </member>
        <member name="M:FlyingEyeEnemy.OnMeleeAttack(UnityEngine.GameObject)">
            <summary>
            called when the enemy is in melee range and executes an attack
            </summary>
            <param name="player">a player</param>
        </member>
        <member name="M:FlyingEyeEnemy.ResetCurrentAttackValue">
            <summary>
            this is used to reset the attack animation, because of Unity's sub-par animation system
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:FlyingEyeEnemy.TakeDamage(System.Single)">
            <summary>
            takes the damage of
            </summary>
            <param name="hp">amount of hp taken</param>
        </member>
        <member name="M:FlyingEyeEnemy.Die">
            <summary>
            die method
            </summary>
        </member>
        <member name="M:FlyingEyeEnemy.Destruct">
            <summary>
            callback by common entity
            </summary>
        </member>
        <member name="T:LittleFightingRobot">
            <summary>
            small but deadly
            </summary>
        </member>
        <member name="F:LittleFightingRobot.explosionPrefab">
            <summary>
            explosion prefab
            </summary>
        </member>
        <member name="F:LittleFightingRobot.smoke">
            <summary>
            instance of the smoke prefab when robot died
            </summary>
        </member>
        <member name="F:LittleFightingRobot.smokePrefab">
            <summary>
            smoke prefab
            </summary>
        </member>
        <member name="F:LittleFightingRobot.projectilePrefab">
            <summary>
            the robot's shot
            </summary>
        </member>
        <member name="F:LittleFightingRobot.projectileShotAudioClip">
            <summary>
            audio when played when shooting
            </summary>
        </member>
        <member name="F:LittleFightingRobot.lastPosition">
            <summary>
            used for setting the walk speed for the animation controller
            </summary>
        </member>
        <member name="F:LittleFightingRobot.animator">
            <summary>
            the character animator
            </summary>
        </member>
        <member name="M:LittleFightingRobot.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:LittleFightingRobot.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:LittleFightingRobot.OnRangeAttack">
            <summary>
            called when ready for a ranged attack
            </summary>
        </member>
        <member name="M:LittleFightingRobot.TakeRangeAttack">
            <summary>
            execute the ranged attack
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:LittleFightingRobot.Die">
            <summary>
            called when dying
            </summary>
        </member>
        <member name="M:LittleFightingRobot.Destruct">
            <summary>
            called eventually when DEAD
            </summary>
        </member>
        <member name="T:ItemDropper">
            <summary>
            this is a static class for dropping items
            example usage: ItemDropper.DropMicrochip(gameObject);
            </summary>
        </member>
        <member name="F:ItemDropper.CommonItemChance">
            <summary>
            chances that can be adjusted to improve the dropping experience
            </summary>
        </member>
        <member name="F:ItemDropper.RareItemChance">
            <summary>
            see above
            </summary>
        </member>
        <member name="F:ItemDropper.microchipPrefab">
            <summary>
            Microchip prefab to instantiate
            </summary>
        </member>
        <member name="M:ItemDropper.DropMicrochip(UnityEngine.Transform)">
            <summary>
            drops one microchip at a specified location
            </summary>
            <param name="transform">where to drop</param>
        </member>
        <member name="M:ItemDropper.DropItem(UnityEngine.Transform,System.String)">
            <summary>
            statically drops an item at a position, this will NOT cache the item
            note that the prefab still has to be in a "Resources" folder
            </summary>
            <param name="transform">where to drop</param>
            <param name="prefabName">what to drop</param>
        </member>
        <member name="F:ItemDropper.commonItemNames">
            <summary>
            defines the prefab names which are considered "common", those should be in a "Resources" folder!
            </summary>
        </member>
        <member name="F:ItemDropper.rareItemNames">
            <summary>
            s.a. only for "rare"
            </summary>
        </member>
        <member name="F:ItemDropper.dropData">
            <summary>
            contains items for "rare", "common"
            </summary>
        </member>
        <member name="F:ItemDropper.dynamicDropChances">
            <summary>
            see above
            </summary>
        </member>
        <member name="M:ItemDropper.DropItemOfType(UnityEngine.Transform,System.String)">
            <summary>
            drops an item of a specified type, respecting drop chance etc.
            </summary>
            <param name="transform">where to drop</param>
            <param name="type">what kind of item to drop</param>
        </member>
        <member name="M:ItemDropper.DynamicDrop(UnityEngine.Transform,System.Single)">
            <summary>
            a microchip is worth 1
            </summary>
            <param name="transform">where to drop</param>
            <param name="value">how valuable the drop should be (currency: microchips)</param>
        </member>
        <member name="T:ItemDropper.ItemDropData">
            <summary>
            keeping track of not only the prefab but also the last drop etc.
            </summary>
        </member>
        <member name="F:ItemDropper.ItemDropData.prefab">
            <summary>
            which item
            </summary>
        </member>
        <member name="F:ItemDropper.ItemDropData.actuality">
            <summary>
            how recent is the last drop
            </summary>
        </member>
        <member name="M:ItemDropper.ItemDropData.#ctor(UnityEngine.GameObject)">
            <summary>
            a constructor
            </summary>
            <param name="_prefab">with a prefab</param>
        </member>
        <member name="M:ItemDropper.ItemDropData.Degenerate">
            <summary>
            become less recent
            </summary>
        </member>
        <member name="T:EnemyHitUnit">
            <summary>
            needed to hit stuff
            </summary>
        </member>
        <member name="F:EnemyHitUnit.damage">
            <summary>
            Damage which will Make by Collision on Igor
            </summary>
        </member>
        <member name="F:EnemyHitUnit.effect">
            <summary>
            some effect
            </summary>
        </member>
        <member name="F:EnemyHitUnit.enable">
            <summary>
            flag for detecting collision
            </summary>
        </member>
        <member name="F:EnemyHitUnit.faction">
            <summary>
            faction this object belongs to. Will only damage other factions
            </summary>
        </member>
        <member name="M:EnemyHitUnit.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            Unity Callback
            </summary>
            <param name="collider">a collider</param>
        </member>
        <member name="T:Fire">
            <summary>
            a fire class
            </summary>
        </member>
        <member name="F:Fire.lightSource">
            <summary>
            The light of the fire
            </summary>
        </member>
        <member name="F:Fire.minIntensity">
            <summary>
            Minimal intensity of the light
            </summary>
        </member>
        <member name="F:Fire.maxIntensity">
            <summary>
            Maximal intensity of the light
            </summary>
        </member>
        <member name="M:Fire.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:BrokenCeilingLamp">
            <summary>
            Makes a ceiling lamp flickering
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.on">
            <summary>
            on = on, off = currently flickering
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.lastFlicker">
            <summary>
            Time since last flickering
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.maxTimeToFlicker">
            <summary>
            Max time until a flicker happens.
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.maxFlickerLength">
            <summary>
            Max flicker length
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.onMaterial">
            <summary>
            Material for display
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.offMaterial">
            <summary>
            Material for display
            </summary>
        </member>
        <member name="F:BrokenCeilingLamp.nextChange">
            <summary>
            some variable
            </summary>
        </member>
        <member name="M:BrokenCeilingLamp.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:BrokenCeilingLamp.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="T:Chest">
            <summary>
            chest to get items from
            </summary>
        </member>
        <member name="T:IUsable">
            <summary>
            interface for all usable objects
            </summary>
        </member>
        <member name="M:IUsable.OnUse(UnityEngine.GameObject)">
            <summary>
            called when the object is being used
            </summary>
            <param name="by">by who</param>
        </member>
        <member name="F:Chest.dropscript">
            <summary>
            script which will used on Items to animate the drop from the chest
            </summary>
        </member>
        <member name="F:Chest.items">
            <summary>
            items which will dropped by use the crate
            </summary>
        </member>
        <member name="F:Chest.open">
            <summary>
            flag for the open state of the crate
            </summary>
        </member>
        <member name="M:Chest.Start">
            <summary>
            call by Unity
            </summary>
        </member>
        <member name="M:Chest.OnUse(UnityEngine.GameObject)">
            <summary>
            create react on use
            </summary>
            <param name="by">by who</param>
        </member>
        <member name="M:Chest.ItemDrop">
            <summary>
            instantiate the items in the items list and add the animation to them
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:Conveyor">
            <summary>
            transporting conveyor
            </summary>
        </member>
        <member name="F:Conveyor.speed">
            <summary>
            speed of movement
            </summary>
        </member>
        <member name="M:Conveyor.OnTriggerStay(UnityEngine.Collider)">
            <summary>
            Unity Callback
            </summary>
            <param name="collider">a collider</param>
        </member>
        <member name="T:DestructionTrigger">
            <summary>
            triggering when all objects are destroyed
            </summary>
        </member>
        <member name="T:ITrigger">
            <summary>
            a trigger will call "OnTrigger(GameObject by, bool isTriggered)" in any connected objects when the
            trigger condition is met.
            It is important to note that "by" can, in some cases, be "null"
            </summary>
        </member>
        <member name="M:ITrigger.AddTriggerable(Triggerable)">
            <summary>
            used to set triggerable objects
            </summary>
            <param name="triggerable">object to add</param>
        </member>
        <member name="M:ITrigger.IsTriggered">
            <summary>
            returns the current state of the trigger
            </summary>
            <returns>trigger state</returns>
        </member>
        <member name="M:ITrigger.SetOneShotTrigger(System.Boolean)">
            <summary>
            if set to true, the trigger will only work once (for example: open a door and never close it again)
            </summary>
            <param name="makeOneShotTrigger">whether to make one shot</param>
        </member>
        <member name="F:DestructionTrigger.isTriggered">
            <summary>
            whether is triggered
            </summary>
        </member>
        <member name="F:DestructionTrigger.isOneShotTrigger">
            <summary>
            if true, the trigger will only work once
            </summary>
        </member>
        <member name="F:DestructionTrigger.hasBeenTriggeredOnce">
            <summary>
            one shot?
            </summary>
        </member>
        <member name="F:DestructionTrigger.connectedObjects">
            <summary>
            used to set triggerable objects via Unity
            </summary>
        </member>
        <member name="M:DestructionTrigger.AddTriggerable(Triggerable)">
            <summary>
            used to set triggerable objects
            </summary>
            <param name="triggerable">to add</param>
        </member>
        <member name="M:DestructionTrigger.IsTriggered">
            <summary>
            returns the current state of the trigger
            </summary>
            <returns>if triggered</returns>
        </member>
        <member name="M:DestructionTrigger.SetOneShotTrigger(System.Boolean)">
            <summary>
            sets whether the trigger will only work once
            </summary>
            <param name="makeOneShot">if enable</param>
        </member>
        <member name="M:DestructionTrigger.OnUse(UnityEngine.GameObject)">
            <summary>
            should be called when the object "by" wants to use the trigger (via a usage action)
            </summary>
            <param name="by">by who</param>
        </member>
        <member name="F:DestructionTrigger.destructionObjects">
            <summary>
            list of objects that all need to be destroyed to trigger the action
            </summary>
        </member>
        <member name="M:DestructionTrigger.Update">
            <summary>
            Unity Update
            </summary>
        </member>
        <member name="T:Door">
            <summary>
            a door class
            </summary>
        </member>
        <member name="F:Door.doorOpenSound">
            <summary>
            plays once when the door moves
            </summary>
        </member>
        <member name="F:Door.doorCloseSound">
            <summary>
            plays once when the door moves
            </summary>
        </member>
        <member name="F:Door.animator">
            <summary>
            for internal use
            </summary>
        </member>
        <member name="F:Door.isOpen">
            <summary>
            state of the door
            </summary>
        </member>
        <member name="M:Door.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            called by the trigger when it's activated
            </summary>
            <param name="by">by who</param>
            <param name="isTriggered">if triggered</param>
        </member>
        <member name="M:Door.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="T:Elevator">
            <summary>
            elevator room script
            </summary>
        </member>
        <member name="F:Elevator.animator">
            <summary>
            for internal use
            </summary>
        </member>
        <member name="F:Elevator.isOpen">
            <summary>
            state of the door
            </summary>
        </member>
        <member name="F:Elevator.inAnimation">
            <summary>
            for preventing race conditions within an animation
            </summary>
        </member>
        <member name="F:Elevator.frontCollider">
            <summary>
            Collider for the front doors
            </summary>
        </member>
        <member name="M:Elevator.Start">
            <summary>
            run on start
            </summary>
        </member>
        <member name="M:Elevator.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            called by the trigger when it's activated
            </summary>
            <param name="by">the game object that calls the trigger</param>
            <param name="isTriggered">indicates whether it's triggered or not</param>
        </member>
        <member name="M:Elevator.RunClosingAnimation">
            <summary>
            runs closing animation
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:Elevator.RunOpeningAnimation">
            <summary>
            runs opening animation
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:ElevatorLoader">
            <summary>
            elevator loader
            </summary>
        </member>
        <member name="M:ElevatorLoader.Awake">
            <summary>
            run before start to destruct itself if there is already an elevator loader on the same position
            </summary>
        </member>
        <member name="T:FloorTrigger">
            <summary>
            a walk-on trigger
            </summary>
        </member>
        <member name="F:FloorTrigger.tag">
            <summary>
            Tag which need a game object to activate the Trigger
            </summary>
        </member>
        <member name="F:FloorTrigger.isTriggered">
            <summary>
            current state
            </summary>
        </member>
        <member name="F:FloorTrigger.isOneShotTrigger">
            <summary>
            if true, the trigger will only work once
            </summary>
        </member>
        <member name="F:FloorTrigger.hasBeenTriggeredOnce">
            <summary>
            one shot?
            </summary>
        </member>
        <member name="F:FloorTrigger.radius">
            <summary>
            the radius will be set automatically to fit the size of the plane
            </summary>
        </member>
        <member name="F:FloorTrigger.actualCheckingBounds">
            <summary>
            after a quick check against the sphere, check against the following bounds
            </summary>
        </member>
        <member name="F:FloorTrigger.connectedObjects">
            <summary>
            used to set triggerable objects via Unity
            </summary>
        </member>
        <member name="M:FloorTrigger.AddTriggerable(Triggerable)">
            <summary>
            used to set triggerable objects
            </summary>
            <param name="triggerable">to add</param>
        </member>
        <member name="M:FloorTrigger.OnUse(UnityEngine.GameObject)">
            <summary>
            should be called when the object "by" wants to use the trigger (via a usage action)
            </summary>
            <param name="by">by who</param>
        </member>
        <member name="M:FloorTrigger.IsTriggered">
            <summary>
            returns the current state of the trigger
            </summary>
            <returns>if triggered</returns>
        </member>
        <member name="M:FloorTrigger.SetOneShotTrigger(System.Boolean)">
            <summary>
            sets whether the trigger will only work once
            </summary>
            <param name="makeOneShot">whether to make one shot</param>
        </member>
        <member name="M:FloorTrigger.Start">
            <summary>
            Unity Start
            </summary>
        </member>
        <member name="M:FloorTrigger.Update">
            <summary>
            Unity Update
            </summary>
        </member>
        <member name="T:MoveToCeiling">
            <summary>
            Moves the object to the ceiling. Pretty basic routine... No collider detection, etc, only doing a raycast
            at THE MIDDLE of the object upwards
            </summary>
        </member>
        <member name="F:MoveToCeiling.moveSpeed">
            <summary>
            How fast the object moves to the ceiling
            </summary>
        </member>
        <member name="M:MoveToCeiling.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:MoveToCeiling.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="T:PushableBox">
            <summary>
            Pushable box.
            
            Needs a collider and has to be a cube. Needs the tag "Usable". Should only rotated horizontally, otherwise weird things will happen...
            </summary>
        </member>
        <member name="F:PushableBox.moveSpeed">
            <summary>
            Amount the box should be used at each push/pull step
            </summary>
        </member>
        <member name="F:PushableBox.oldPosition">
            <summary>
            Old position, prior to moving
            </summary>
        </member>
        <member name="F:PushableBox._fallingDown">
            <summary>
            Set when falling down to prevent pulling/pushing
            </summary>
        </member>
        <member name="F:PushableBox.fallSpeed">
            <summary>
            Defines how fast the box should fall
            </summary>
        </member>
        <member name="F:PushableBox._realSize">
            <summary>
            Our real size: internal variable
            </summary>
        </member>
        <member name="F:PushableBox.gotRealRealSize">
            <summary>
            False, if we only have an estimate
            </summary>
        </member>
        <member name="M:PushableBox.CalculateRealSize">
            <summary>
            Since Unity is sometimes buggy (GetComponent&lt;MeshFilter&gt;().mesh throws an exception, although everything is not null...)
            we may have to do it more then once... 
            </summary>
        </member>
        <member name="M:PushableBox.SavePosition">
            <summary>
            save the current position
            </summary>
        </member>
        <member name="M:PushableBox.LoadOldPosition">
            <summary>
            Load the saved position
            </summary>
        </member>
        <member name="M:PushableBox.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:PushableBox.PushingAllowed(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Returns if you are allowed to push the object
            </summary>
            <param name="igorGO">Igor game object</param>
            <param name="forward">moving forward?</param>
            <returns>Returns if you are allowed to push the object</returns>
        </member>
        <member name="M:PushableBox.GetPushingDirection(UnityEngine.Vector3)">
            <summary>
            Gets the direction, in which it will be pushed forward. Only north/west/south/east possible
            </summary>
            <param name="playerpos">Position of the player</param>
            <returns>Direction, in which it will be pushed forward</returns>
        </member>
        <member name="M:PushableBox.OnUse(UnityEngine.GameObject)">
            <summary>
            should be called when the object "obj" wants to use the trigger (via a usage action: IUsable)
            </summary>
            <param name="obj">Object which triggered it</param>
        </member>
        <member name="M:PushableBox.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:PushableBox.FallDown">
            <summary>
            Lets the manually box fall down
            </summary>
        </member>
        <member name="P:PushableBox.FallingDown">
            <summary>
            Set when falling down to prevent pulling/pushing
            </summary>
        </member>
        <member name="P:PushableBox.RealSize">
            <summary>
            Our real size, read only
            </summary>
        </member>
        <member name="T:Siren">
            <summary>
            Siren control script
            </summary>
        </member>
        <member name="F:Siren.lights">
            <summary>
            List of lights to rotate
            </summary>
        </member>
        <member name="F:Siren.speed">
            <summary>
            Speed of the rotating lights
            </summary>
        </member>
        <member name="F:Siren.isEnabled">
            <summary>
            Used for enabling and disabling the siren
            </summary>
        </member>
        <member name="F:Siren.intEnabled">
            <summary>
            Saves if the lights are enabled or disabled
            </summary>
        </member>
        <member name="M:Siren.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Siren.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:SteamyObstacle">
            <summary>
            THIS IS HOT - Steam which kills when touched
            </summary>
        </member>
        <member name="M:SteamyObstacle.OnTriggerStay(UnityEngine.Collider)">
            <summary>
            Unity callback
            </summary>
            <param name="other">a collider</param>
        </member>
        <member name="T:SwitchTrigger">
            <summary>
            Switch, allows to trigger stuff
            </summary>
        </member>
        <member name="F:SwitchTrigger.enable">
            <summary>
            Flag for enabling the trigger
            </summary>
        </member>
        <member name="F:SwitchTrigger.animator">
            <summary>
            for internal use
            </summary>
        </member>
        <member name="F:SwitchTrigger.isTriggered">
            <summary>
            is it triggered?
            </summary>
        </member>
        <member name="F:SwitchTrigger.isOneShotTrigger">
            <summary>
            whether the trigger will only work once
            </summary>
        </member>
        <member name="F:SwitchTrigger.hasBeenTriggeredOnce">
            <summary>
            only needed when isOneShotTrigger
            </summary>
        </member>
        <member name="F:SwitchTrigger.connectedObjects">
            <summary>
            used to set triggerable objects via Unity
            </summary>
        </member>
        <member name="M:SwitchTrigger.AddTriggerable(Triggerable)">
            <summary>
            used to set triggerable objects via Unity
            </summary>
            <param name="triggerable">Object to add to trigger list</param>
        </member>
        <member name="M:SwitchTrigger.SetOneShotTrigger(System.Boolean)">
            <summary>
            sets whether the trigger will only work once
            </summary>
            <param name="makeOneShot">set it to one shot or not</param>
        </member>
        <member name="M:SwitchTrigger.OnUse(UnityEngine.GameObject)">
            <summary>
            should be called when the object "by" wants to use the trigger (via a usage action: IUsable)
            </summary>
            <param name="by">the object which triggered this switch</param>
        </member>
        <member name="M:SwitchTrigger.IsTriggered">
            <summary>
            returns the current state of the trigger
            </summary>
            <returns>state of the trigger</returns>
        </member>
        <member name="M:SwitchTrigger.Start">
            <summary>
            Unity Start
            </summary>
        </member>
        <member name="T:WallTexture">
            <summary>
            Automatically scales a texture on a wall.
            </summary>
        </member>
        <member name="F:WallTexture.scaleFactor">
            <summary>
            The global scaling factor for both directions (x and y).
            </summary>
        </member>
        <member name="M:WallTexture.Start">
            <summary>
            Set wall texture scaling according to cube scaling.
            </summary>
        </member>
        <member name="T:WeightTrigger">
            <summary>
            WeightTrigger: Put a PushableBox or some rigidbody on top to trigger it
            </summary>
        </member>
        <member name="F:WeightTrigger.triggeringMass">
            <summary>
            mass that has to be reached to trigger the events
            </summary>
        </member>
        <member name="F:WeightTrigger.objectsCurrentlyInside">
            <summary>
            objects currently on the trigger
            </summary>
        </member>
        <member name="M:WeightTrigger.CheckMass">
            <summary>
            check mass and/or exec trigger
            </summary>
        </member>
        <member name="M:WeightTrigger.OnCollisionEnter(UnityEngine.Collision)">
            <summary>
            Called by Unity
            </summary>
            <param name="collision">set by Unity</param>
        </member>
        <member name="M:WeightTrigger.OnCollisionExit(UnityEngine.Collision)">
            <summary>
            Called by Unity
            </summary>
            <param name="collision">set by Unity</param>
        </member>
        <member name="T:DragNDrop">
            <summary>
            the drag and drop system
            </summary>
        </member>
        <member name="F:DragNDrop.dragNDropInstance">
            <summary>
            the only ring
            </summary>
        </member>
        <member name="M:DragNDrop.GetInstance">
            <summary>
            returns something
            </summary>
            <returns>it is the singleton!</returns>
        </member>
        <member name="M:DragNDrop.StartDrag(System.String,DragNDrop.MetaData.Source,UnityEngine.Texture2D)">
            <summary>
            starts dragging
            </summary>
            <param name="info">the name</param>
            <param name="source">the source</param>
            <param name="texture">some picture</param>
        </member>
        <member name="M:DragNDrop.GetDrop">
            <summary>
            returns null or MetaData in case of drop
            </summary>
            <returns>the meta data</returns>
        </member>
        <member name="F:DragNDrop.metaData">
            <summary>
            some meta data
            </summary>
        </member>
        <member name="M:DragNDrop.Update">
            <summary>
            Unity Update
            </summary>
        </member>
        <member name="M:DragNDrop.OnGUI">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="T:DragNDrop.MetaData">
            <summary>
            drag and drop meta data
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.info">
            <summary>
            the info
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.source">
            <summary>
            where from
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.drawingTexture">
            <summary>
            the image
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.x">
            <summary>
            some coordinates
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.y">
            <summary>
            some coordinates
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.age">
            <summary>
            drop events might die of old age
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.isActive">
            <summary>
            drag events only become active after the mouse moved for a certain time
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.size">
            <summary>
            size of the texture. Don't set (it's used for fading)
            </summary>
        </member>
        <member name="M:DragNDrop.MetaData.#ctor(System.String,DragNDrop.MetaData.Source,UnityEngine.Texture2D)">
            <summary>
            a constructor
            </summary>
            <param name="_info">some info</param>
            <param name="_source">random source</param>
            <param name="_texture">what is this</param>
        </member>
        <member name="T:DragNDrop.MetaData.Source">
            <summary>
            specifies the source of the drag and drop event
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.Source.OTHER">
            <summary>
            Come from somewhere else.
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.Source.SKILL_TREE">
            <summary>
            Comes from the skill tree.
            </summary>
        </member>
        <member name="F:DragNDrop.MetaData.Source.INVENTORY">
            <summary>
            Comes from the inventory.
            </summary>
        </member>
        <member name="T:Drawing">
            <summary>
            Class for drawing stuff. Currently only DrawLine() possible
            </summary>
        </member>
        <member name="F:Drawing.lineTexture">
            <summary>
            1x1 pixel used for the line
            </summary>
        </member>
        <member name="F:Drawing.onexoneRect">
            <summary>
            Reusable rectangle for drawing later on
            </summary>
        </member>
        <member name="M:Drawing.DrawLine(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Rect,UnityEngine.Color,System.Single)">
            <summary>
            Draw a line
            </summary>
            <param name="pointA">Start point</param>
            <param name="pointB">End point</param>
            <param name="drawRect">Area to draw in - set to (0, 0, 0, 0) to disable clipping</param>
            <param name="color">color to paint the line in</param>
            <param name="width">width of the line</param>
        </member>
        <member name="M:Drawing.GetCollisionWithBoarder(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Rect)">
            <summary>
            Returns the first collision of the line going from "from" to "to" or (-1, -1) if no collision happens
            </summary>
            <param name="from">Line starting point</param>
            <param name="to">Line ending point</param>
            <param name="rect">Rectangle to calculate collision with</param>
            <returns>Returns the first collision of the line going from "from" to "to" or (-1, -1) if no collision happens</returns>
        </member>
        <member name="M:Drawing.InRect(UnityEngine.Vector2,UnityEngine.Rect)">
            <summary>
            Returns whether the point is in the rectangle or not
            </summary>
            <param name="point">the point</param>
            <param name="rect">the area</param>
            <returns>the result</returns>
        </member>
        <member name="M:Drawing.ReturnMinimalPositive(System.Collections.Generic.IList{System.Single})">
            <summary>
            Returns smallest positive (>=0) value. If none are available, return -1
            </summary>
            <param name="values">the values</param>
            <returns>Smallest positive (>=0) value or -1 if failure</returns>
        </member>
        <member name="T:MessageBoard">
            <summary>
            the message board system
            </summary>
        </member>
        <member name="F:MessageBoard.msgBoardInstance">
            <summary>
            for internal use only
            </summary>
        </member>
        <member name="M:MessageBoard.GetMessageBoardInstance">
            <summary>
            internal. To retrieve and/or create the message board instance
            </summary>
            <returns>returns the only ring</returns>
        </member>
        <member name="M:MessageBoard.AddMessage(System.String,UnityEngine.Texture2D,System.Boolean)">
            <summary>
            adds a message to the message board that will be shown when possible
            </summary>
            <param name="message">some message</param>
            <param name="icon">some image</param>
            <param name="dialogueMessage">if in center of screen</param>
        </member>
        <member name="M:MessageBoard.DrawMessageBackground(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            draws a message background into the GUI.
            Note that the actual texture might extent over the original rectangle (which will be the center)
            </summary>
            <param name="x">coordinate a</param>
            <param name="y">coordinate b</param>
            <param name="wdt">some width</param>
            <param name="hgt">some height</param>
        </member>
        <member name="M:MessageBoard.DrawMessageBackground(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            wrapper of something
            </summary>
            <param name="x">some coordinate</param>
            <param name="y">some coordinate</param>
            <param name="wdt">some width</param>
            <param name="hgt">some height</param>
        </member>
        <member name="M:MessageBoard.DrawMessageBackground(UnityEngine.Rect)">
            <summary>
            draws a message background into the GUI.
            Note that the actual texture might extent over the original rectangle (which will be the center)
            </summary>
            <param name="r">Rectangle to draw</param>
        </member>
        <member name="F:MessageBoard.guiStyle">
            <summary>
            GUI style for the normal messages
            </summary>
        </member>
        <member name="F:MessageBoard.guiStyleDialogue">
            <summary>
            GUI style for the dialogue messages
            </summary>
        </member>
        <member name="M:MessageBoard.GetGUIStyle(System.Boolean)">
            <summary>
            the style used for the messages
            </summary>
            <param name="forDialogues">whether to return the style for dialogue boxes</param>
            <returns>the style for boxes</returns>
        </member>
        <member name="F:MessageBoard.maxHeight">
            <summary>
            maximum displayed height of several messages together as factor of Screen.height
            </summary>
        </member>
        <member name="F:MessageBoard.margin">
            <summary>
            margin between two displayed messages
            </summary>
        </member>
        <member name="F:MessageBoard.marginLeft">
            <summary>
            adds a margin on the left side of the messages (f.e. for the HP bars)
            </summary>
        </member>
        <member name="F:MessageBoard.messages">
            <summary>
            list of messages
            </summary>
        </member>
        <member name="F:MessageBoard.borderWidth">
            <summary>
            width of the border of the message backgrounds' texture
            </summary>
        </member>
        <member name="M:MessageBoard.Add(System.String,UnityEngine.Texture2D,System.Boolean)">
            <summary>
            for internal use. Called by AddMessage
            </summary>
            <param name="message">message to add</param>
            <param name="icon">some image</param>
            <param name="dialogueMessage">if in center</param>
        </member>
        <member name="M:MessageBoard.OnGUI">
            <summary>
            Unity OnGUI
            </summary>
        </member>
        <member name="F:MessageBoard.backgroundTextureParts">
            <summary>
            contains images
            </summary>
        </member>
        <member name="M:MessageBoard.GenerateMessageBackgroundTexture">
            <summary>
            creates the textures used to draw the background when called for the very first time
            </summary>
        </member>
        <member name="M:MessageBoard.CopyTexture(UnityEngine.Texture2D,MessageBoard.BackgroundTexturePartIndices,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            creates a new texture from a part of a bigger texture
            </summary>
            <param name="from">some image</param>
            <param name="toIndex">some target</param>
            <param name="fromX">some source</param>
            <param name="fromY">more source</param>
            <param name="w">width, the</param>
            <param name="h">height, a random</param>
        </member>
        <member name="M:MessageBoard.DrawMsgBackground(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            will draw the background of a message - however, the background might extend over the original rectangle
            </summary>
            <param name="x">some coordinate</param>
            <param name="y">some coordinate</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
        </member>
        <member name="M:MessageBoard.DrawTexture(MessageBoard.BackgroundTexturePartIndices,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            draws a certain texture 
            </summary>
            <param name="index">index of texture to draw</param>
            <param name="x">some coordinate</param>
            <param name="y">some coordinate</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
        </member>
        <member name="T:MessageBoard.BackgroundTexturePartIndices">
            <summary>
            list of sensible names
            </summary>
        </member>
        <member name="T:MessageBoardMessage">
            <summary>
            a message displayed on the message board
            </summary>
        </member>
        <member name="F:MessageBoardMessage.totalMessageWidth">
            <summary>
            parameters controlling the behavior
            </summary>
        </member>
        <member name="F:MessageBoardMessage.maxTimeInSecondsPerChar">
            <summary>
            see above
            </summary>
        </member>
        <member name="F:MessageBoardMessage.fadeInTimeInSeconds">
            <summary>
            see above
            </summary>
        </member>
        <member name="F:MessageBoardMessage.fadeOutTimeInSeconds">
            <summary>
            see above
            </summary>
        </member>
        <member name="F:MessageBoardMessage.icon">
            <summary>
            can be omitted
            </summary>
        </member>
        <member name="F:MessageBoardMessage.message">
            <summary>
            the message
            </summary>
        </member>
        <member name="F:MessageBoardMessage.guiContent">
            <summary>
            the contents
            </summary>
        </member>
        <member name="F:MessageBoardMessage.isDialogueMessage">
            <summary>
            whether the message is displayed in the middle of the screen
            </summary>
        </member>
        <member name="F:MessageBoardMessage.age">
            <summary>
            used to fade the element in and out and then finally remove it
            </summary>
        </member>
        <member name="F:MessageBoardMessage.shouldBeRemoved">
            <summary>
            to check whether the message wants to be removed after the current frame
            </summary>
        </member>
        <member name="M:MessageBoardMessage.#ctor(System.String,UnityEngine.Texture2D,System.Boolean)">
            <summary>
            creates a new message, that's what constructors usually do
            </summary>
            <param name="_message">the message</param>
            <param name="_icon">the icon</param>
            <param name="_isDialogueMessage">if in center</param>
        </member>
        <member name="M:MessageBoardMessage.GetTotalMessageWidth">
            <summary>
            for internal use
            </summary>
            <returns>the total message width</returns>
        </member>
        <member name="M:MessageBoardMessage.GetTextWidth(System.Single)">
            <summary>
            for internal use
            </summary>
            <param name="totalWdt">some width</param>
            <returns>the text width</returns>
        </member>
        <member name="M:MessageBoardMessage.GetHeight">
            <summary>
            returns the height of the element after word-wrapping
            </summary>
            <returns>the height</returns>
        </member>
        <member name="M:MessageBoardMessage.Draw(System.Single,System.Single)">
            <summary>
            draws the element with an offset relative to the top edge of the screen
            </summary>
            <param name="offsetX">the offset</param>
            <param name="offsetY">the offset</param>
        </member>
        <member name="T:SkillBar">
            <summary>
            on-screen skill bar which is always displayed
            the player can see the currently selected skills as well as items that are assigned to hotkeys
            </summary>
        </member>
        <member name="F:SkillBar.maxHotkeyCount">
            <summary>
            allow NO less (but also no more)
            </summary>
        </member>
        <member name="F:SkillBar.skillBarInstance">
            <summary>
            the only instance, it's a singleton! Magic.
            </summary>
        </member>
        <member name="M:SkillBar.GetInstance">
            <summary>
            retrieves the SkillBar that is currently in game
            </summary>
            <returns>yeah, well, the instance</returns>
        </member>
        <member name="F:SkillBar.cooldownBarTexture">
            <summary>
            shown when skills/items are on cooldown
            </summary>
        </member>
        <member name="F:SkillBar.mouse1Texture">
            <summary>
            left mouse button symbol
            </summary>
        </member>
        <member name="F:SkillBar.mouse2Texture">
            <summary>
            right mouse button symbol
            </summary>
        </member>
        <member name="F:SkillBar.items">
            <summary>
            contains the currently displayed (thus selected) items and skills
            </summary>
        </member>
        <member name="M:SkillBar.#ctor">
            <summary>
            constructs a skill bar
            </summary>
        </member>
        <member name="M:SkillBar.Update">
            <summary>
            Unity Update
            </summary>
        </member>
        <member name="M:SkillBar.OnHotkeyPressed(System.Int32)">
            <summary>
            when an item should be executed
            </summary>
            <param name="currentHotkey">which one</param>
        </member>
        <member name="M:SkillBar.AssignSlot(System.Int32,System.String,SkillBar.SkillBarItem.ItemType,UnityEngine.Texture2D)">
            <summary>
            put item/skill on slot
            </summary>
            <param name="index">the index</param>
            <param name="item">some item</param>
            <param name="type">item type</param>
            <param name="texture">the texture</param>
        </member>
        <member name="M:SkillBar.OnGUI">
            <summary>
            Unity OnGUI
            </summary>
        </member>
        <member name="T:SkillBar.SkillBarItem">
            <summary>
            one item in the skill bar
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.iconTexture">
            <summary>
            the texture of the icon
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.name">
            <summary>
            the name of the icon, will be used to acquire said REAL item
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.type">
            <summary>
            the type of the item
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.cooldown">
            <summary>
            current cooldown for that item
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.lastMaxCooldown">
            <summary>
            to calculate the width of the cooldown bar
            </summary>
        </member>
        <member name="M:SkillBar.SkillBarItem.#ctor(SkillBar.SkillBarItem.ItemType,System.String,UnityEngine.Texture2D)">
            <summary>
            constructs a new skill bar item, it's a constructor
            </summary>
            <param name="_type">the type</param>
            <param name="_name">the name</param>
            <param name="_iconTexture">an image</param>
        </member>
        <member name="M:SkillBar.SkillBarItem.StartCooldown(System.Single)">
            <summary>
            starts a cooldown
            </summary>
            <param name="seconds">how long</param>
        </member>
        <member name="M:SkillBar.SkillBarItem.DecCooldown">
            <summary>
            decreases the cooldown
            </summary>
        </member>
        <member name="M:SkillBar.SkillBarItem.HasCooldown">
            <summary>
            if cooldown is active
            </summary>
            <returns>true or false</returns>
        </member>
        <member name="M:SkillBar.SkillBarItem.GetRelativeCooldown">
            <summary>
            returns the part of the cooldown still remaining (between 0 and 1)
            </summary>
            <returns>normalized between 0 and 1</returns>
        </member>
        <member name="M:SkillBar.SkillBarItem.GetName">
            <summary>
            returns a name
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:SkillBar.SkillBarItem.GetTexture">
            <summary>
            the texture
            </summary>
            <returns>some texture</returns>
        </member>
        <member name="T:SkillBar.SkillBarItem.ItemType">
            <summary>
            the type of the item
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.ItemType.INVALID">
            <summary>
            It's an invalid item.
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.ItemType.ITEM">
            <summary>
            It's an item type.
            </summary>
        </member>
        <member name="F:SkillBar.SkillBarItem.ItemType.SKILL">
            <summary>
            It's an skill type.
            </summary>
        </member>
        <member name="T:SkillTree">
            <summary>
            the marvelous skill tree
            </summary>
        </member>
        <member name="F:SkillTree.MarginLeftRight">
            <summary>
            some margin
            </summary>
        </member>
        <member name="F:SkillTree.MarginTopBottom">
            <summary>
            more margin
            </summary>
        </member>
        <member name="F:SkillTree.skillTreeInstance">
            <summary>
            one instance
            </summary>
        </member>
        <member name="M:SkillTree.GetInstance">
            <summary>
            returns the current skill tree
            </summary>
            <returns>some instance</returns>
        </member>
        <member name="F:SkillTree.levelUpSymbol">
            <summary>
            symbol that is drawn on the skill icons for every level
            </summary>
        </member>
        <member name="F:SkillTree.maxSkillNodePositionX">
            <summary>
            for just the very best user experience!
            </summary>
        </member>
        <member name="F:SkillTree.maxSkillNodePositionY">
            <summary>
            for just the very best user experience!
            </summary>
        </member>
        <member name="M:SkillTree.ReportNodePosition(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            nodes should, after adjusting to layout, report their position back
            </summary>
            <param name="x">some coordinate</param>
            <param name="y">some coordinate</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
        </member>
        <member name="F:SkillTree.nodes">
            <summary>
            a random list of nodes
            </summary>
        </member>
        <member name="F:SkillTree.isEnabled">
            <summary>
            current state of GUI
            </summary>
        </member>
        <member name="M:SkillTree.Show">
            <summary>
            show the item
            </summary>
        </member>
        <member name="M:SkillTree.Hide">
            <summary>
            hide it again
            </summary>
        </member>
        <member name="M:SkillTree.Update">
            <summary>
            Unity Update
            </summary>
        </member>
        <member name="M:SkillTree.RefreshAllStates">
            <summary>
            refreshes the states (availability etc.) of all nodes
            </summary>
        </member>
        <member name="M:SkillTree.Recalculate">
            <summary>
            recalculates the whole tree
            </summary>
        </member>
        <member name="M:SkillTree.IsPositionFree(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            returns whether a certain position in the graph can be filled by a node
            </summary>
            <param name="x">the coordinates</param>
            <param name="y">the coordinates</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
            <returns>true or false</returns>
        </member>
        <member name="M:SkillTree.DrawLevelUpSymbol(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            draws a symbol
            </summary>
            <param name="x">some coordinates</param>
            <param name="y">some coordinates</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
        </member>
        <member name="M:SkillTree.DrawFrame(System.Single,System.Single,System.Single,System.Single,UnityEngine.Rect,UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            draws a frame
            </summary>
            <param name="x">some coordinates</param>
            <param name="y">some coordinates</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
            <param name="drawRect">Area to draw in - clip otherwise. Set to (0, 0, 0, 0) disable clipping</param>
            <param name="color">some color</param>
            <param name="width">line width</param>
            <param name="antialease">on or off</param>
        </member>
        <member name="M:SkillTree.DrawCross(System.Single,System.Single,System.Single,System.Single,UnityEngine.Rect,UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            draws a cross
            </summary>
            <param name="x">some coordinates</param>
            <param name="y">some coordinates</param>
            <param name="wdt">the width</param>
            <param name="hgt">the height</param>
            <param name="drawRect">Area to draw in - clip otherwise. Set to (0, 0, 0, 0) disable clipping</param>
            <param name="color">some color</param>
            <param name="width">line width</param>
            <param name="antialease">on or off</param>
        </member>
        <member name="F:SkillTree.scrollViewPosition">
            <summary>
            internal use
            </summary>
        </member>
        <member name="M:SkillTree.OnGUI">
            <summary>
            Unity OnGUI
            </summary>
        </member>
        <member name="T:SkillTree.SkillTreeNode">
            <summary>
            one node in the skill tree
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.stdWidth">
            <summary>
            the standard width
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.x">
            <summary>
            some coordinates
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.y">
            <summary>
            some coordinates
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.wdt">
            <summary>
            some coordinates
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.hgt">
            <summary>
            some coordinates
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.skillData">
            <summary>
            some data
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.parent">
            <summary>
            the logical parent of this skill, might go both directions
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.canBeSelected">
            <summary>
            whether the skill can be selected in the skill tree to either upgrade it or learn it
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.neededItemInformation">
            <summary>
            texture + tooltip for the item that is currently lacking
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.skillTooltip">
            <summary>
            some tooltip
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.drawingName">
            <summary>
            the name to draw
            </summary>
        </member>
        <member name="F:SkillTree.SkillTreeNode.drawingTexture">
            <summary>
            the icon
            </summary>
        </member>
        <member name="M:SkillTree.SkillTreeNode.#ctor(Skills.SkillData,SkillTree.SkillTreeNode)">
            <summary>
            constructs something
            </summary>
            <param name="_skillData">the data</param>
            <param name="_parent">the parent</param>
        </member>
        <member name="M:SkillTree.SkillTreeNode.RefreshState(SkillTree)">
            <summary>
            refreshes only soft data (which is NOT the position and layout in the tree)
            </summary>
            <param name="tree">the parent tree</param>
        </member>
        <member name="M:SkillTree.SkillTreeNode.Refresh(SkillTree)">
            <summary>
            recalculates everything
            </summary>
            <param name="tree">the parent tree</param>
        </member>
        <member name="M:SkillTree.SkillTreeNode.Draw(SkillTree,UnityEngine.Rect)">
            <summary>
            obvious pretty much
            </summary>
            <param name="tree">the parent tree</param>
            <param name="drawArea">Area to draw in - clip otherwise. Set to (0, 0, 0, 0) disable clipping</param>
        </member>
        <member name="M:SkillTree.SkillTreeNode.OnSkillSelected(SkillTree)">
            <summary>
            when a skill is selected
            </summary>
            <param name="tree">still the parent</param>
        </member>
        <member name="T:Game">
            <summary>
            Global status class for our game
            </summary>
        </member>
        <member name="F:Game.paused">
            <summary>
            Internal variable for the paused status
            </summary>
        </member>
        <member name="F:Game.pauseHandlers">
            <summary>
            Registered handlers
            </summary>
        </member>
        <member name="M:Game.AddPauseHandler(IPauseHandler)">
            <summary>
            Adds a new handler
            </summary>
            <param name="handler">The handler to register</param>
        </member>
        <member name="M:Game.RemovePauseHandler(IPauseHandler)">
            <summary>
            Removes a handler
            </summary>
            <param name="handler">Handler to remove</param>
        </member>
        <member name="M:Game.TriggerPause">
            <summary>
            Triggers the event
            </summary>
        </member>
        <member name="F:Game.currentDifficulty">
            <summary>
            Current difficulty mode.
            </summary>
        </member>
        <member name="F:Game.isMenuOpen">
            <summary>
            shows if an menu (inventory, skill gui, etc...) is open
            </summary>
        </member>
        <member name="F:Game.cutscene">
            <summary>
            Internal variable for the cutscene status
            </summary>
        </member>
        <member name="F:Game.ignoreBars">
            <summary>
            Enables the bars to be hidden
            </summary>
        </member>
        <member name="F:Game.cutsceneHandlers">
            <summary>
            Registered handlers
            </summary>
        </member>
        <member name="M:Game.AddCutsceneHandler(IPauseHandler)">
            <summary>
            Adds a new handler
            </summary>
            <param name="handler">The handler to register</param>
        </member>
        <member name="M:Game.RemoveCutsceneHandler(IPauseHandler)">
            <summary>
            Removes a handler
            </summary>
            <param name="handler">Handler to remove</param>
        </member>
        <member name="M:Game.TriggerCutscene">
            <summary>
            Triggers the cutscene event
            </summary>
        </member>
        <member name="F:Game.igorGameObject">
            <summary>
            caches the igor game object to speed up successive calls
            </summary>
        </member>
        <member name="M:Game.GetIgor">
            <summary>
            caches the igor game object to speed up successive calls
            </summary>
            <returns>IGOR WHITE SPACE</returns>
        </member>
        <member name="M:Game.SpawnIgor">
            <summary>
            Spawns an Igor if there is no Igor
            </summary>
        </member>
        <member name="F:Game.igorComponent">
            <summary>
            caches the igor game object to speed up successive calls
            </summary>
        </member>
        <member name="M:Game.GetIgorComponent">
            <summary>
            Gets Igor, but as Igor class
            </summary>
            <returns>Igor, but as Igor object</returns>
        </member>
        <member name="F:Game.currentVolume">
            <summary>
            The current audio volume.
            </summary>
        </member>
        <member name="F:Game.currentVolumeInitialized">
            <summary>
            flag for whether the current volume has been at least queried once and those been loaded from the preferences
            </summary>
        </member>
        <member name="F:Game._backgroundSongs">
            <summary>
            internal background sound song list
            </summary>
        </member>
        <member name="M:Game.PlayAudioAtStaticPosition(UnityEngine.AudioClip,UnityEngine.Vector3,System.Single)">
            <summary>
            Play an audio clip at a specific static position.
            </summary>
            <param name="clip">The clip to play.</param>
            <param name="position">The position at which it should be played.</param>
            <param name="volumeScale">The volume scale.</param>
        </member>
        <member name="M:Game.PlayAudioAtParent(UnityEngine.AudioClip,UnityEngine.Transform,System.Single)">
            <summary>
            Play an audio clip attached to a transform.
            </summary>
            <param name="clip">The clip to play.</param>
            <param name="parent">The transform to which it should be attached.</param>
            <param name="volumeScale">The volume scale.</param>
        </member>
        <member name="P:Game.IsPaused">
            <summary>
            Paused as boolean.
            </summary>
        </member>
        <member name="P:Game.PausedAsFloat">
            <summary>
            Paused as float
            </summary>
        </member>
        <member name="P:Game.PausedAsInt">
            <summary>
            Paused as integer.
            </summary>
        </member>
        <member name="P:Game.DifficultyMultiplier">
            <summary>
            Float we can multiply for difficulty things. Is 1 for lowest and higher for higher difficulties.
            </summary>
        </member>
        <member name="P:Game.IsCutscene">
            <summary>
            True if inside cutscene
            </summary>
        </member>
        <member name="P:Game.InGame">
            <summary>
            Returns whether we are allowed to move, etc, or not
            </summary>
        </member>
        <member name="P:Game.CutsceneAsFloat">
            <summary>
            1 if inside cutscene else 0
            </summary>
        </member>
        <member name="P:Game.CutsceneAsInt">
            <summary>
            1 if inside cutscene else 0
            </summary>
        </member>
        <member name="P:Game.CurrentVolume">
            <summary>
            The current audio volume.
            </summary>
        </member>
        <member name="P:Game.BackgroundSongs">
            <summary>
            The list of all background songs.
            </summary>
        </member>
        <member name="T:Game.Difficulty">
            <summary>
            Difficulty modes of the game.
            </summary>
        </member>
        <member name="F:Game.Difficulty.Medium">
            <summary>
            The normal difficulty.
            </summary>
        </member>
        <member name="F:Game.Difficulty.Hard">
            <summary>
            It's harder to play the game.
            </summary>
        </member>
        <member name="T:Igor">
            <summary>
            Behavior class for our main character.
            <remarks>Attention: The CameraTarget object which is attached to Igor and which is set as the target for the IgorCamera has to be the second child.</remarks>
            </summary>
        </member>
        <member name="F:Igor.maxStartPushingTime">
            <summary>
            Maximum time until we abort startPushing
            </summary>
        </member>
        <member name="F:Igor.hidden">
            <summary>
            Should Igor be displayed or not?
            </summary>
        </member>
        <member name="F:Igor.turningSpeed">
            <summary>
            How fast should Igor turn when beginning to walk after mouse rotation while standing.
            </summary>
        </member>
        <member name="M:Igor.RotateToCameraSmoothly">
            <summary>
            Rotate Igor to our camera direction smoothly (has to be called multiple times).
            </summary>
        </member>
        <member name="M:Igor.RotateToCameraHard">
            <summary>
            Rotate Igor to our camera direction in one step (aka directly).
            </summary>
        </member>
        <member name="F:Igor.initialMaxHealthPoints">
            <summary>
            Initial health points without skill points
            </summary>
        </member>
        <member name="F:Igor.initialMaxMana">
            <summary>
            Initial mana points without skill points
            </summary>
        </member>
        <member name="F:Igor.initialTimeUntilRegeneration">
            <summary>
            Initial time until health regeneration without skill points
            </summary>
        </member>
        <member name="F:Igor.initialHealthRegeneration">
            <summary>
            Initial health regeneration without skill points
            </summary>
        </member>
        <member name="F:Igor.initialManaRegeneration">
            <summary>
            Initial mana regeneration without skill points
            </summary>
        </member>
        <member name="F:Igor.initialJumpForce">
            <summary>
            Initial jump force without skill points
            </summary>
        </member>
        <member name="F:Igor.initialJumpForceRegeneration">
            <summary>
            Initial jump regeneration without skill points
            </summary>
        </member>
        <member name="F:Igor.initialSpeed">
            <summary>
            Initial speed without skill points
            </summary>
        </member>
        <member name="F:Igor.skillpointsPerLevel">
            <summary>
            Defines how much skill points igor gets at level up
            </summary>
        </member>
        <member name="F:Igor.skillpoints">
            <summary>
            Unused skill points
            </summary>
        </member>
        <member name="F:Igor.level">
            <summary>
            Current level
            </summary>
        </member>
        <member name="F:Igor.experience">
            <summary>
            experience at CURRENT level, not overall experience.
            </summary>
        </member>
        <member name="M:Igor.UnityStart_Skills">
            <summary>
            Called by the Unity Start() method. Extracted for better readability.
            </summary>
        </member>
        <member name="M:Igor.ResetExperience">
            <summary>
            resets experience points
            </summary>
        </member>
        <member name="M:Igor.AddExperience(System.UInt32)">
            <summary>
            adds experience points to igor
            </summary>
            <param name="amount">amount of experience points</param>
        </member>
        <member name="F:Igor.healthBarTexture">
            <summary>
            Texture for healthBar
            </summary>
        </member>
        <member name="F:Igor.manaBarTexture">
            <summary>
            Texture for manaBar
            </summary>
        </member>
        <member name="F:Igor.jumpBarTexture">
            <summary>
            Texture for jumpBar
            </summary>
        </member>
        <member name="F:Igor.expBarTexture">
            <summary>
            Texture for experience Bar
            </summary>
        </member>
        <member name="F:Igor.barBackgroundTexture">
            <summary>
            Texture for the background of the bars
            </summary>
        </member>
        <member name="F:Igor.skillPointMessageguiStyle">
            <summary>
            How to draw the skill point message
            </summary>
        </member>
        <member name="M:Igor.Awake">
            <summary>
            Use this for initialization.
            Attention: Initialization in Awake state is very important,please don't move it to Start()
            </summary>
        </member>
        <member name="M:Igor.Start">
            <summary>
            Use this for initialization.
            </summary>
        </member>
        <member name="M:Igor.Update">
            <summary>
            Update is called once per frame.
            </summary>
        </member>
        <member name="M:Igor.FixedUpdate">
            <summary>
            Update is called once per frame.
            </summary>
        </member>
        <member name="M:Igor.UnityUpdate_State_Normal">
            <summary>
            Called by the Unity Start() method. Extracted for better readability.
            </summary>
        </member>
        <member name="F:Igor.currentMovementDirection">
            <summary>
            the direction that Igor will move this frame
            </summary>
        </member>
        <member name="F:Igor.jumpWasCappedAtCeilingLastMove">
            <summary>
            don't fall down every frame when flying at the ceiling..
            </summary>
        </member>
        <member name="F:Igor.backwardSlowdown">
            <summary>
            define the factor to lower the backwards and sideways speed in relation to forward speed
            </summary>
        </member>
        <member name="M:Igor.ResetCurrentMovement">
            <summary>
            should be called once per frame before the movement is executed
            </summary>
        </member>
        <member name="M:Igor.AddCurrentMovement(UnityEngine.Vector3)">
            <summary>
            if you want to move Igor, use this function
            </summary>
            <param name="direction">direction to move into</param>
        </member>
        <member name="M:Igor.ExecCurrentMovement">
            <summary>
            called once per frame to execute the movement
            </summary>
        </member>
        <member name="M:Igor.MoveOnPlane">
            <summary>
            Move forward, backward, left and right if user presses the corresponding keys.
            </summary>
        </member>
        <member name="F:Igor.gameOverImage">
            <summary>
            Needed for game over screen
            </summary>
        </member>
        <member name="F:Igor.objectHelpMessageDelay">
            <summary>
            Time until a objectHelpMessage should be shown
            </summary>
        </member>
        <member name="F:Igor.objectHelpMessageWaited">
            <summary>
            Time already waited
            </summary>
        </member>
        <member name="M:Igor.UnityStart_GUI">
            <summary>
            Called by the Unity Start() method. Extracted for better readability.
            </summary>
        </member>
        <member name="M:Igor.OnGUI">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:Igor.DrawObjectHelpMessage(UnityEngine.GameObject,System.Int32,System.Int32,System.String)">
            <summary>
            Renders a beautiful help message for an object
            </summary>
            <param name="obj">The object</param>
            <param name="rectSizeX">How big the rectangle should be</param>
            <param name="rectSizeY">How big the rectangle should be</param>
            <param name="text">The text to display</param>
        </member>
        <member name="F:Igor.inAction">
            <summary>
            define witch attack  is current run  (0 means no attack is run)
            </summary>
        </member>
        <member name="F:Igor.sparklingParticlesPrefab">
            <summary>
            used to highlight usable objects
            </summary>
        </member>
        <member name="F:Igor.currentHighlightingEffect">
            <summary>
            the currently active effect to highlight the closest, usable object
            </summary>
        </member>
        <member name="F:Igor.currentHighlightedObject">
            <summary>
            used for drawing "Use XYZ"-text in OnGUI
            </summary>
        </member>
        <member name="F:Igor.useEffectItem">
            <summary>
            safe the Effect from the Item witch is used on igor
            </summary>
        </member>
        <member name="M:Igor.CheckUsableObjects">
            <summary>
            look for and highlight usable objects (that are tagged "Usable") in front of Igor.
            Use them on key stroke.
            </summary>
        </member>
        <member name="F:Igor.useObjectInFrontCallbackObject">
            <summary>
            object which will receive an OnUse callback after the use animation has been played
            the object should only use a if(!Igor.PlayUseObjectInFrontAnimation(this)) to check for validity
            </summary>
        </member>
        <member name="M:Igor.PlayUseObjectInFrontAnimation(UnityEngine.GameObject)">
            <summary>
            plays an animation and locks the hands
            </summary>
            <param name="usable">usable object</param>
            <returns>true if the object can be used instantly, otherwise false and might call again</returns>
        </member>
        <member name="M:Igor.UseObjectInFrontAnimation">
            <summary>
            unlocks and stops the animation eventually, too
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:Igor.UseItemSelfAnimation">
            <summary>
            Play the animation for the Item Use
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:Igor.UseItemSelf(UnityEngine.GameObject)">
            <summary>
            play Animation and particle effect for used item of igor
            </summary>
            <param name="partikleffect">particle effect for the item which is used</param>
        </member>
        <member name="F:Igor.timeSinceIgorDied">
            <summary>
            Needed for game over screen
            </summary>
        </member>
        <member name="M:Igor.UnityUpdate_State_Dead">
            <summary>
            Is called by the Unity Update() method. Extracted for better readability.
            </summary>
        </member>
        <member name="M:Igor.Die">
            <summary>
            When Igor dies we play the die animation and disable the jetpack.
            </summary>
        </member>
        <member name="F:Igor.realSize">
            <summary>
            Our real size: internal variable
            </summary>
        </member>
        <member name="F:Igor.currentPushBox">
            <summary>
            When pushing: current box
            </summary>
        </member>
        <member name="F:Igor.pushLeft">
            <summary>
            how much we still have to push
            </summary>
        </member>
        <member name="F:Igor.startPushingTime">
            <summary>
            How long we are in startPushing, so we can abort after a certain time
            </summary>
        </member>
        <member name="M:Igor.UnityStart_Pushing">
            <summary>
            Is called by the Unity Start() method. Extracted for better readability.
            </summary>
        </member>
        <member name="M:Igor.UnityUpdate_State_Pushing">
            <summary>
            Is called by the Unity Update() method. Extracted for better readability.
            </summary>
        </member>
        <member name="M:Igor.UnityUpdate_State_StartPushing">
            <summary>
            Is called by the Unity Update() method. Extracted for better readability.
            </summary>
        </member>
        <member name="M:Igor.InitiatePushing(PushableBox)">
            <summary>
            Start pushing a box
            </summary>
            <param name="pb">the box</param>
        </member>
        <member name="M:Igor.EndPushing">
            <summary>
            End pushing a box
            </summary>
        </member>
        <member name="M:Igor.EndPushingForLoad">
            <summary>
            End pushing a box for load game ,call this function only in GameDataRecover
            </summary>
        </member>
        <member name="F:Igor.fallSpeed">
            <summary>
            Defines how fast Igor falls when MANUALLY FALL is used
            </summary>
        </member>
        <member name="M:Igor.FallDown(System.Single)">
            <summary>
            Lets Igor fall down.
            </summary>
            <param name="speedFactor">speed factor - lets igor fall slower/faster</param>
            <remarks>Only needed if isKinematic = true!</remarks>
        </member>
        <member name="M:Igor.GetMana">
            <summary>
            Returns the current mana.
            </summary>
            <returns>the current mana.</returns>
        </member>
        <member name="M:Igor.DoMana(System.Single)">
            <summary>
            manipulates Igor's mana
            </summary>
            <param name="amount">The amount to add or subtract from the mana</param>
        </member>
        <member name="F:Igor.jumpForce">
            <summary>
            force which is consumed by bust(jump)
            </summary>
        </member>
        <member name="F:Igor.jumpCurrentForce">
            <summary>
            define the power which remains for the boost(jump)
            </summary>
        </member>
        <member name="F:Igor.jumpMaxHeight">
            <summary>
            max height which can igor reach
            </summary>
        </member>
        <member name="F:Igor.currentJumpMaxY">
            <summary>
            The maximum position on the y axis during our current jump
            </summary>
        </member>
        <member name="F:Igor.jumpSpeed">
            <summary>
            define how fast igor moves higher in the jump
            </summary>
        </member>
        <member name="F:Igor.jumpCooldown">
            <summary>
            time delay to the next jump
            </summary>
        </member>
        <member name="F:Igor.inJump">
            <summary>
            flag representing that igor is currently jumping
            </summary>
        </member>
        <member name="F:Igor.jumpHeight">
            <summary>
            The height of our jump (y position in our world).
            </summary>
        </member>
        <member name="F:Igor.jumpForceRegeneration">
            <summary>
            set the regeneration of the jump force
            </summary>
        </member>
        <member name="M:Igor.UnityUpdate_JumpAudioVolume">
            <summary>
            Called by Unity Update() function. Sets the volume of the jetpack depending on jumping or not.
            </summary>
        </member>
        <member name="M:Igor.Jump">
            <summary>
            Jumps if user presses the 'Jump' key.
            </summary>
        </member>
        <member name="M:Igor.RegenerateJumpForce">
            <summary>
            Regenerate jump force
            </summary>
        </member>
        <member name="F:Igor.animator">
            <summary>
            reference to the animator
            </summary>
        </member>
        <member name="M:Igor.StartAnimation(System.String)">
            <summary>
            Start animation with specific name.
            </summary>
            <param name="animation">the name of the animation.</param>
        </member>
        <member name="M:Igor.GetAnimationLength(System.String)">
            <summary>
            Return the length of an animation.
            </summary>
            <param name="animation">The animation.</param>
            <returns>The length.</returns>
        </member>
        <member name="P:Igor.Hidden">
            <summary>
            Property to get and set whether Igor should be hidden (not displayed) or not.
            </summary>
        </member>
        <member name="P:Igor.Experience">
            <summary>
            experience at CURRENT level, not overall experience. read only.
            </summary>
        </member>
        <member name="P:Igor.ExpUntilLevelUp">
            <summary>
            How much experience is left to the next level
            </summary>
        </member>
        <member name="P:Igor.RealSize">
            <summary>
            Our real size, read only
            </summary>
        </member>
        <member name="T:IgorCamera">
            <summary>
            Igor camera
            </summary>
        </member>
        <member name="F:IgorCamera.dontCheckThisTag">
            <summary>
            Camera will not check objects with this tag for coming closer.
            </summary>
        </member>
        <member name="F:IgorCamera.target">
            <summary>
            The target to follow.
            </summary>
        </member>
        <member name="F:IgorCamera.distance">
            <summary>
            Which distance should we keep from the target.
            </summary>
        </member>
        <member name="F:IgorCamera.currentDistance">
            <summary>
            The actual distance we have from our enemy.
            </summary>
        </member>
        <member name="F:IgorCamera.minimalDistance">
            <summary>
            The minimal distance from the target.
            </summary>
        </member>
        <member name="F:IgorCamera.maximalDistance">
            <summary>
            The maximal distance from the target.
            </summary>
        </member>
        <member name="F:IgorCamera.rotationSpeed">
            <summary>
            How fast should the camera rotate?
            </summary>
        </member>
        <member name="F:IgorCamera.minimalAngle">
            <summary>
            The maximal angle for the vertical rotation (0 = directly behind, 90 = directly above, -90 = directly below).
            </summary>
        </member>
        <member name="F:IgorCamera.maximalAngle">
            <summary>
            The maximal angle for the vertical rotation (0 = directly behind, 90 = directly above, -90 = directly below).
            </summary>
        </member>
        <member name="F:IgorCamera.x">
            <summary>
            The rotation x and y components.
            </summary>
        </member>
        <member name="F:IgorCamera.y">
            <summary>
            The rotation x and y components.
            </summary>
        </member>
        <member name="F:IgorCamera.crosshair">
            <summary>
            crosshair transform
            </summary>
        </member>
        <member name="M:IgorCamera.Start">
            <summary>
            Set the camera initially to the correct position / rotation.
            </summary>
        </member>
        <member name="M:IgorCamera.LateUpdate">
            <summary>
            This is called after all other Update-Methods.
            </summary>
        </member>
        <member name="T:MicrowaveAttackSphere">
            <summary>
            The sphere which is cast by a microwave attack.
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.damage">
            <summary>
            Damage the bullet does to the player/enemy
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.damagesPlayer">
            <summary>
            Toggles damage to the player
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.damagesEnemies">
            <summary>
            Toggles damage to the player
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.hitPrefab">
            <summary>
            When something is hit, one object of HitPrefab is created at
            the position of the bullet.
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.maxScale">
            <summary>
            Maximum size (in scale units) of the sphere.
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.parentTransform">
            <summary>
            The parent transform which should be our center all the time.
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.parentTranslation">
            <summary>
            The translation from out parent transform.
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.outerSphere">
            <summary>
            The outer sphere (which can be seen from outside)
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.innerSphere">
            <summary>
            The inner sphere (which can be seen from inside)
            </summary>
        </member>
        <member name="F:MicrowaveAttackSphere.hitObjects">
            <summary>
            Save a list of all objects we have already hit.
            </summary>
        </member>
        <member name="M:MicrowaveAttackSphere.Start">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:MicrowaveAttackSphere.Update">
            <summary>
            Update is called once per frame
            </summary>
        </member>
        <member name="T:IAction">
            <summary>
            some action interface
            </summary>
        </member>
        <member name="M:IAction.OnStart">
            <summary>
            random method
            </summary>
        </member>
        <member name="M:IAction.OnFinish">
            <summary>
            random method
            </summary>
        </member>
        <member name="M:IAction.OnUpdate">
            <summary>
            random method
            </summary>
        </member>
        <member name="M:IAction.GUI">
            <summary>
            random method
            </summary>
        </member>
        <member name="M:IAction.Finished">
            <summary>
            random method
            </summary>
            <returns>if finished</returns>
        </member>
        <member name="T:IInvItem">
            <summary>
            Prefabs implementing this Interface can be used in the inventory
            The items' preview texture will be GetDisplayName()+"InventoryIcon" - it MUST exist in a Resources-folder
            </summary>
        </member>
        <member name="M:IInvItem.GetDisplayName">
            <summary>
            The name of the object be be shown in the inventory view
            </summary>
            <returns>the display name</returns>
        </member>
        <member name="M:IInvItem.GetMaxStackSize">
            <summary>
            Maximal stacking size for this item.
            </summary>
            <returns>the size</returns>
        </member>
        <member name="M:IInvItem.Drop">
            <summary>
            Called when the player tries to drop this item.
            </summary>
            <returns>True, when the player can drop the item (will be removed from the inventory) of false, 
            when the item could not be dropped.</returns>
        </member>
        <member name="M:IInvItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item.
            </summary>
            <param name="entity">by who</param>
            <returns>True, when the player can use the item (will be removed from the inventory) of false,
            when the item could not be used.</returns>
        </member>
        <member name="M:IInvItem.Combinable(IInvItem)">
            <summary>
            Determines if the two items are combinable.
            </summary>
            <param name="other">The other object.</param>
            <returns>True if the two items are combinable, false if not.</returns>
        </member>
        <member name="M:IInvItem.Combine(IInvItem)">
            <summary>
            Called, when the player tries to combine objects. Only called if combinable() returned true.
            </summary>
            <param name="other">Other object this object is about to be combined with</param>
            <returns>Name of the resulting inventory</returns>
        </member>
        <member name="T:IPauseHandler">
            <summary>
            Interface for classes for them to be notified on pause changes
            </summary>
        </member>
        <member name="M:IPauseHandler.PauseStateChanged">
            <summary>
            Called by the Game object when the pause status changes
            </summary>
        </member>
        <member name="T:ISkill">
            <summary>
            general interface for all skills
            </summary>
        </member>
        <member name="M:ISkill.GetName">
            <summary>
            Return the skill name.
            </summary>
            <returns>the name</returns>
        </member>
        <member name="M:ISkill.GetIconTexture">
            <summary>
            Return the corresponding icon.
            </summary>
            <returns>the texture</returns>
        </member>
        <member name="M:ISkill.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            called when used
            </summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:ISkill.OnUseWithoutMana(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            similar to OnUse but only called when the player has not enough mana for the skill
            when returning true, the skill will be set on cooldown BUT no mana will be drained
            this can be used to specify f.e. fallback skills (electro fist may just use fist when low on mana)
            </summary>
            <param name="by">by who</param>
            <param name="igorInstance">the igor</param>
            <param name="level">for level</param>
            <returns>whether successful</returns>
        </member>
        <member name="M:ISkill.OnLevelChange(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill goes to another level.</summary>
            <param name="by">game object that levels the skill up</param>
            <param name="igorInstance">igor (class instance) IFF igor levels the skill</param>
            <param name="level">new level of the skill (starts at 1)</param>
            <returns>whether the level up was successful</returns>
        </member>
        <member name="M:ISkill.IsPassive">
            <summary>
            Return whether a skill is active (like attacks) or passive (walk speed, jump height, ...)
            </summary>
            <returns>Whether this skill is passive.</returns>
        </member>
        <member name="M:ISkill.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:ISkill.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:ISkill.GetNeededSkills">
            <summary>
            returns a list of skill names that are needed for this very skill to be learned
            </summary>
            <returns>list of skills</returns>
        </member>
        <member name="M:ISkill.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>list of items</returns>
        </member>
        <member name="T:Inventory">
            <summary>
            Inventory for the player
            </summary>
        </member>
        <member name="F:Inventory.itemIconCache">
            <summary>
            caches the icons to be able to access them even without an object in the scene
            </summary>
        </member>
        <member name="M:Inventory.GetTextureForItem(System.String)">
            <summary>
            returns the texture for an item name
            </summary>
            <param name="itemName">name of item</param>
            <returns>the texture</returns>
        </member>
        <member name="M:Inventory.#ctor">
            <summary>
            some constructor
            </summary>
        </member>
        <member name="F:Inventory.items">
            <summary>
            The list of items in this inventory
            </summary>
        </member>
        <member name="F:Inventory.visible">
            <summary>
            Sets the inventory to visible
            </summary>
        </member>
        <member name="F:Inventory.collectionSound">
            <summary>
            item collection sound
            </summary>
        </member>
        <member name="M:Inventory.Awake">
            <summary>
            Use this for initialization
            </summary>
        </member>
        <member name="M:Inventory.Update">
            <summary>
            Called for every frame
            </summary>
        </member>
        <member name="M:Inventory.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            Called when the inventory holder collides with an object
            </summary>
            <param name="other">The potential item we collided with</param>
        </member>
        <member name="M:Inventory.SetShow(System.Boolean)">
            <summary>
            Sets the visibility of the inventory
            </summary>
            <param name="show">True for visible, false for invisible</param>
        </member>
        <member name="M:Inventory.OnGUI">
            <summary>
            Called when the GUI should be drawn
            </summary>
        </member>
        <member name="M:Inventory.InsertItem(IInvItem)">
            <summary>
            Inserts the item into the inventory.
            </summary>
            <param name="item">The item to be inserted</param>
        </member>
        <member name="F:Inventory.scrollPos">
            <summary>
            Scroll position of the inventory
            </summary>
        </member>
        <member name="F:Inventory.controllerPos">
            <summary>
            The position of the item that is selected by the controller
            </summary>
        </member>
        <member name="F:Inventory.mousePos">
            <summary>
            The last mouse position
            Used to detect mouse movements
            </summary>
        </member>
        <member name="F:Inventory.cooldown">
            <summary>
            Cooldown for controller input
            </summary>
        </member>
        <member name="M:Inventory.DrawInventory">
            <summary>
            Draws the inventory on the screen
            </summary>
        </member>
        <member name="M:Inventory.DrawButton(System.Int32,System.Int32)">
            <summary>
            Draws a single inventory button
            </summary>
            <param name="num">number of the item in the items list</param>
            <param name="perRow">number per row</param>
        </member>
        <member name="M:Inventory.InventoryClear">
            <summary>
            clears the inventory
            </summary>
        </member>
        <member name="M:Inventory.FillInventoryFromSaveData(System.Collections.ArrayList)">
            <summary>
            for loading
            </summary>
            <param name="list">fill data</param>
        </member>
        <member name="M:Inventory.HasItem(System.String)">
            <summary>
            Finds out if the given item exists in the inventory
            </summary>
            <param name="itemName">The display name of the object to find.</param>
            <returns>True if it exists</returns>
        </member>
        <member name="M:Inventory.CountItem(System.String)">
            <summary>
            Counts the amount of items of the given type in the inventory
            </summary>
            <param name="itemName">Name of the items to count</param>
            <returns>Number of the items of this type in the inventory</returns>
        </member>
        <member name="M:Inventory.UseItem(System.String)">
            <summary>
            Uses the item
            </summary>
            <param name="itemName">Name of the item to use</param>
        </member>
        <member name="M:Inventory.RemoveItem(System.String)">
            <summary>
            Removes an item for the inventory
            </summary>
            <param name="itemName">Name of the item to remove</param>
        </member>
        <member name="M:Inventory.GetItemList">
            <summary>
            Returns the list of items in this inventory
            </summary>
            <returns>A string array containing all inventory items in alphabetical order</returns>
        </member>
        <member name="T:Inventory.InventoryItem">
            <summary>
            Represents an item in the inventory
            </summary>
        </member>
        <member name="F:Inventory.InventoryItem.texture">
            <summary>
            texture of the item, will be cached
            </summary>
        </member>
        <member name="F:Inventory.InventoryItem.instance">
            <summary>
            The instance of the item.
            </summary>
        </member>
        <member name="F:Inventory.InventoryItem.stackS">
            <summary>
            The size of the stack
            </summary>
        </member>
        <member name="M:Inventory.InventoryItem.#ctor(IInvItem,System.Int32)">
            <summary>
            Initializes a new InventoryItem instance
            </summary>
            <param name="item">The item type of this stack</param>
            <param name="initialStackSize">Size of the stack to start with</param>
        </member>
        <member name="M:Inventory.InventoryItem.Stack(IInvItem)">
            <summary>
            Adds the item to the item stack if possible and returns if it worked
            </summary>
            <param name="item">Item to add to the stack</param>
            <returns>True if it could be added to the stack, false if not</returns>
        </member>
        <member name="M:Inventory.InventoryItem.Remove">
            <summary>
            Removes an item from the stack.
            </summary>
            <returns>True if the entry should be destroyed.</returns>
        </member>
        <member name="M:Inventory.InventoryItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player wants to use an item
            </summary>
            <param name="entity">the entity</param>
            <returns>True if the instance can be destroyed</returns>
        </member>
        <member name="M:Inventory.InventoryItem.GetDrawable">
            <summary>
            returns texture
            </summary>
            <returns>the texture</returns>
        </member>
        <member name="P:Inventory.InventoryItem.DisplayName">
            <summary>
            The name of the item to be shown to the user
            </summary>
        </member>
        <member name="P:Inventory.InventoryItem.StackSize">
            <summary>
            Size of the stack
            </summary>
        </member>
        <member name="T:BasicItem">
            <summary>
            basic item class with some standard methods
            </summary>
        </member>
        <member name="T:Prism">
            <summary>
            Prism item
            </summary>
        </member>
        <member name="M:Prism.PickUp">
            <summary>
            pick up function
            </summary>
            <returns>the inventory </returns>
        </member>
        <member name="M:Prism.GetName">
            <summary>
            returns ne name of the item
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:Prism.InvItem">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:Prism.InvItem.name">
            <summary>
            name of the inventory item
            </summary>
        </member>
        <member name="M:Prism.InvItem.#ctor(System.String)">
            <summary>
            some constructor
            </summary>
            <param name="_name">some name</param>
        </member>
        <member name="M:Prism.InvItem.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:Prism.InvItem.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:Prism.InvItem.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:Prism.InvItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:Prism.InvItem.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:Prism.InvItem.Combine(IInvItem)">
            <summary>
            combine something
            </summary>
            <param name="other">other object</param>
            <returns>some item</returns>
        </member>
        <member name="F:BasicItem.itemName">
            <summary>
            the name will be used to load icon etc..
            </summary>
        </member>
        <member name="M:BasicItem.GetName">
            <summary>
            returns a name
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:Coil">
            <summary>
            Fan item
            </summary>
        </member>
        <member name="M:Coil.PickUp">
            <summary>
            pick up function
            </summary>
            <returns>the inventory </returns>
        </member>
        <member name="M:Coil.GetName">
            <summary>
            returns ne name of the item
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:Coil.InvItem">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:Coil.InvItem.name">
            <summary>
            name of the inventory item
            </summary>
        </member>
        <member name="M:Coil.InvItem.#ctor(System.String)">
            <summary>
            Create the inventory item with given name.
            </summary>
            <param name="_name">The name of the item.</param>
        </member>
        <member name="M:Coil.InvItem.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:Coil.InvItem.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:Coil.InvItem.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:Coil.InvItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:Coil.InvItem.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:Coil.InvItem.Combine(IInvItem)">
            <summary>
            Called, when the player tries to combine objects. Only called if combinable() returned true.
            </summary>
            <param name="other">Other object this object is about to be combined with</param>
            <returns>Name of the resulting inventory</returns>
        </member>
        <member name="T:EnergyCapsule">
            <summary>
            Heals the players mana
            </summary>
        </member>
        <member name="F:EnergyCapsule.amountToHeal">
            <summary>
            Defines how much the player is healed
            </summary>
        </member>
        <member name="F:EnergyCapsule.healPrefab">
            <summary>
            Created when player heals himself
            </summary>
        </member>
        <member name="M:EnergyCapsule.PickUp">
            <summary>
            makes Energy Capsules pickable
            </summary>
            <returns>the inventory repair kit</returns>
        </member>
        <member name="T:EnergyCapsule.InvEnergyCapsule">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:EnergyCapsule.InvEnergyCapsule.amountToHeal">
            <summary>
            Defines how much the player is healed
            </summary>
        </member>
        <member name="F:EnergyCapsule.InvEnergyCapsule.healPrefab">
            <summary>
            Prefab to instantiate when the player clicks the item
            </summary>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.#ctor(System.Single,UnityEngine.GameObject)">
            <summary>
            Constructor for the inventory item
            </summary>
            <param name="amount">Number of mana points to heal</param>
            <param name="prefab">Prefab of the effect to play when healing</param>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:EnergyCapsule.InvEnergyCapsule.Combine(IInvItem)">
            <summary>
            try to combine
            </summary>
            <param name="other">other object</param>
            <returns>some item</returns>
        </member>
        <member name="T:Fan">
            <summary>
            Fan item
            </summary>
        </member>
        <member name="M:Fan.PickUp">
            <summary>
            pick up function
            </summary>
            <returns>the inventory </returns>
        </member>
        <member name="M:Fan.GetName">
            <summary>
            returns ne name of the item
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:Fan.InvItem">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:Fan.InvItem.name">
            <summary>
            name of the inventory item
            </summary>
        </member>
        <member name="M:Fan.InvItem.#ctor(System.String)">
            <summary>
            some constructor
            </summary>
            <param name="_name">some name</param>
        </member>
        <member name="M:Fan.InvItem.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:Fan.InvItem.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:Fan.InvItem.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:Fan.InvItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:Fan.InvItem.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:Fan.InvItem.Combine(IInvItem)">
            <summary>
            combines stuff
            </summary>
            <param name="other">other object</param>
            <returns>some item</returns>
        </member>
        <member name="T:Microchip">
            <summary>
            microchip class
            </summary>
        </member>
        <member name="F:Microchip.expSparksPrefab">
            <summary>
            particles that will be created when collecting the chip
            </summary>
        </member>
        <member name="F:Microchip.experienceValue">
            <summary>
            How much experience that the microchip has
            </summary>
        </member>
        <member name="M:Microchip.PickUp">
            <summary>
            called when picked up
            </summary>
            <returns>inventory item</returns>
        </member>
        <member name="T:Microwave">
            <summary>
            the microwave item
            </summary>
        </member>
        <member name="M:Microwave.GetName">
            <summary>
            returns a name
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:RepairKit">
            <summary>
            Heals the player
            </summary>
        </member>
        <member name="F:RepairKit.amountToHeal">
            <summary>
            Defines how much the player is healed
            </summary>
        </member>
        <member name="F:RepairKit.healPrefab">
            <summary>
            Created when player heals himself
            </summary>
        </member>
        <member name="F:RepairKit.texture">
            <summary>
            The texture to display in the inventory
            </summary>
        </member>
        <member name="M:RepairKit.PickUp">
            <summary>
            makes repair kit pickable
            </summary>
            <returns>the inventory repair kit</returns>
        </member>
        <member name="F:RepairKit.invRepairKit">
            <summary>
            this object used for save/load "invRepairKit" into/from disk
            </summary>
        </member>
        <member name="M:RepairKit.#ctor">
            <summary>
            constructor for repairKit
            this constructor used for save/load "invRepairKit" into/from disk
            </summary>
        </member>
        <member name="T:RepairKit.InvRepairKit">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:RepairKit.InvRepairKit.amountToHeal">
            <summary>
            Defines how much the player is healed
            </summary>
        </member>
        <member name="F:RepairKit.InvRepairKit.healPrefab">
            <summary>
            Prefab to instantiate when the player clicks the item
            </summary>
        </member>
        <member name="F:RepairKit.InvRepairKit.texture">
            <summary>
            Texture to show in the inventory
            </summary>
        </member>
        <member name="M:RepairKit.InvRepairKit.#ctor(System.Single,UnityEngine.GameObject,UnityEngine.Texture2D)">
            <summary>
            Constructor for the inventory item
            </summary>
            <param name="amount">Number of hit points to heal</param>
            <param name="prefab">Prefab of the effect to play when healing</param>
            <param name="tex">Picture of the Item to show in the inventory</param>
        </member>
        <member name="M:RepairKit.InvRepairKit.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:RepairKit.InvRepairKit.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:RepairKit.InvRepairKit.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:RepairKit.InvRepairKit.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:RepairKit.InvRepairKit.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:RepairKit.InvRepairKit.Combine(IInvItem)">
            <summary>
            won't combine
            </summary>
            <param name="other">other object</param>
            <returns>some object</returns>
        </member>
        <member name="M:RepairKit.InvRepairKit.GetDrawable">
            <summary>
            returns texture
            </summary>
            <returns>the texture</returns>
        </member>
        <member name="T:Spring">
            <summary>
            Spring item
            </summary>
        </member>
        <member name="M:Spring.PickUp">
            <summary>
            pick up function
            </summary>
            <returns>the inventory </returns>
        </member>
        <member name="M:Spring.GetName">
            <summary>
            returns ne name of the item
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:Spring.InvItem">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:Spring.InvItem.name">
            <summary>
            name of the inventory item
            </summary>
        </member>
        <member name="M:Spring.InvItem.#ctor(System.String)">
            <summary>
            Create the inventory item with given name.
            </summary>
            <param name="_name">The name of the item.</param>
        </member>
        <member name="M:Spring.InvItem.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:Spring.InvItem.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:Spring.InvItem.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:Spring.InvItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:Spring.InvItem.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:Spring.InvItem.Combine(IInvItem)">
            <summary>
            Called, when the player tries to combine objects. Only called if combinable() returned true.
            </summary>
            <param name="other">Other object this object is about to be combined with</param>
            <returns>Name of the resulting inventory</returns>
        </member>
        <member name="T:USBStick">
            <summary>
            Fan item
            </summary>
        </member>
        <member name="M:USBStick.PickUp">
            <summary>
            pick up function
            </summary>
            <returns>the inventory </returns>
        </member>
        <member name="M:USBStick.GetName">
            <summary>
            returns ne name of the item
            </summary>
            <returns>the name</returns>
        </member>
        <member name="T:USBStick.InvItem">
            <summary>
            Item for the Inventory
            </summary>
        </member>
        <member name="F:USBStick.InvItem.name">
            <summary>
            name of the inventory item
            </summary>
        </member>
        <member name="M:USBStick.InvItem.#ctor(System.String)">
            <summary>
            Create the inventory item with given name.
            </summary>
            <param name="_name">The name of the item.</param>
        </member>
        <member name="M:USBStick.InvItem.GetDisplayName">
            <summary>
            Returns the name of the item
            </summary>
            <returns>Name of the item to show in the inventory</returns>
        </member>
        <member name="M:USBStick.InvItem.GetMaxStackSize">
            <summary>
            Maximal stacking size
            </summary>
            <returns>Maximal size of the item stack</returns>
        </member>
        <member name="M:USBStick.InvItem.Drop">
            <summary>
            Called when the player tries to drop the item
            </summary>
            <returns>True if the drop was successful</returns>
        </member>
        <member name="M:USBStick.InvItem.Use(UnityEngine.GameObject)">
            <summary>
            Called when the player tries to use the item
            </summary>
            <param name="entity">Instance of the player</param>
            <returns>True if it was used up</returns>
        </member>
        <member name="M:USBStick.InvItem.Combinable(IInvItem)">
            <summary>
            Returns if the item could be combined
            </summary>
            <param name="other">the other item</param>
            <returns>True, if it is combinable</returns>
        </member>
        <member name="M:USBStick.InvItem.Combine(IInvItem)">
            <summary>
            Called, when the player tries to combine objects. Only called if combinable() returned true.
            </summary>
            <param name="other">Other object this object is about to be combined with</param>
            <returns>Name of the resulting inventory</returns>
        </member>
        <member name="T:Loader">
            <summary>
            some loader class
            </summary>
        </member>
        <member name="F:Loader.loadBar">
            <summary>
            some load bar
            </summary>
        </member>
        <member name="F:Loader.current">
            <summary>
            current something
            </summary>
        </member>
        <member name="F:Loader.all">
            <summary>
            no idea
            </summary>
        </member>
        <member name="M:Loader.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Loader.Update">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Loader.OnGUI">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Loader.ShowProgress(System.Int32,System.Int32)">
            <summary>
            shows stuff
            </summary>
            <param name="cur">at the moment</param>
            <param name="max">maximum number</param>
        </member>
        <member name="T:Controls">
            <summary>
            some controls
            </summary>
        </member>
        <member name="F:Controls.mySkin">
            <summary>
            some gui skin
            </summary>
        </member>
        <member name="F:Controls.current">
            <summary>
            current something
            </summary>
        </member>
        <member name="F:Controls.lastSwitch">
            <summary>
            a switch I believe
            </summary>
        </member>
        <member name="F:Controls.lastMousePos">
            <summary>
            last mouse position
            </summary>
        </member>
        <member name="M:Controls.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Controls.OnGUI">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Controls.HandleButton(System.Int32)">
            <summary>
            some callback
            </summary>
            <param name="id">some ID</param>
        </member>
        <member name="T:LoadGameScreen">
            <summary>
            load game screen
            </summary>
        </member>
        <member name="F:LoadGameScreen.mySkin">
            <summary>
            some GUI skin
            </summary>
        </member>
        <member name="F:LoadGameScreen.gameData">
            <summary>
            some game data
            </summary>
        </member>
        <member name="F:LoadGameScreen.saveLoadDatas">
            <summary>
            loading and saving
            </summary>
        </member>
        <member name="M:LoadGameScreen.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:LoadGameScreen.OnGUI">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="T:Loadscreen">
            <summary>
            loading screen class
            </summary>
        </member>
        <member name="F:Loadscreen.timer">
            <summary>
            some timer
            </summary>
        </member>
        <member name="M:Loadscreen.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Loadscreen.DisplayScene">
            <summary>
            some timer
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:MySettings">
            <summary>
            Settings class
            </summary>
        </member>
        <member name="F:MySettings.mySkin">
            <summary>
            new skin
            </summary>
        </member>
        <member name="F:MySettings.sound">
            <summary>
            text for sound button
            </summary>
        </member>
        <member name="F:MySettings.current">
            <summary>
            The current selected menu item
            </summary>
        </member>
        <member name="F:MySettings.lastSwitch">
            <summary>
            Time (float) of the last switch
            </summary>
        </member>
        <member name="F:MySettings.lastMousePos">
            <summary>
            The last mouse position.
            </summary>
        </member>
        <member name="F:MySettings.isPressed">
            <summary>
            is the button pressed
            </summary>
        </member>
        <member name="F:MySettings.timing">
            <summary>
            The timing.
            </summary>
        </member>
        <member name="M:MySettings.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:MySettings.OnGUI">
            <summary>
            Raises the GU event.
            </summary>
        </member>
        <member name="M:MySettings.HandleButton(System.Int32)">
            <summary>
            Handles the button.
            </summary>
            <param name='id'>
            id of the button
            </param>
        </member>
        <member name="T:Score">
            <summary>
            some score
            </summary>
        </member>
        <member name="F:Score.mySkin">
            <summary>
            some skin
            </summary>
        </member>
        <member name="F:Score.lastMousePos">
            <summary>
            last mouse position
            </summary>
        </member>
        <member name="F:Score.current">
            <summary>
            current something
            </summary>
        </member>
        <member name="F:Score.lastSwitch">
            <summary>
            some switch
            </summary>
        </member>
        <member name="M:Score.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Score.OnGUI">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Score.HandleButton(System.Int32)">
            <summary>
            some callback
            </summary>
            <param name="id">some button ID</param>
        </member>
        <member name="T:SplashScreen">
            <summary>
            starting menu
            </summary>
        </member>
        <member name="F:SplashScreen.levelToLoad">
            <summary>
            what to load
            </summary>
        </member>
        <member name="F:SplashScreen.mySkin">
            <summary>
             which skin
            </summary>
        </member>
        <member name="F:SplashScreen.current">
            <summary>
            current what
            </summary>
        </member>
        <member name="F:SplashScreen.lastSwitch">
            <summary>
            some variable
            </summary>
        </member>
        <member name="F:SplashScreen.lastMousePos">
            <summary>
            last position
            </summary>
        </member>
        <member name="M:SplashScreen.Awake">
            <summary>
            Unity Awake
            </summary>
        </member>
        <member name="M:SplashScreen.Start">
            <summary>
            Unity Start
            </summary>
        </member>
        <member name="M:SplashScreen.OnGUI">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:SplashScreen.HandleButton(System.Int32)">
            <summary>
            some callback
            </summary>
            <param name="id">some ID</param>
        </member>
        <member name="T:Matrix2x2">
            <summary>
            2x2 matrix
            </summary>
        </member>
        <member name="F:Matrix2x2.values">
            <summary>
            all 4 values
            </summary>
        </member>
        <member name="M:Matrix2x2.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            2x2 matrix
            </summary>
            <param name="m00">00 parameter</param>
            <param name="m01">01 parameter</param>
            <param name="m10">10 parameter</param>
            <param name="m11">11 parameter</param>
        </member>
        <member name="M:Matrix2x2.Determinant">
            <summary>
            returns the determinant of the matrix
            </summary>
            <returns>the determinant of the matrix</returns>
        </member>
        <member name="T:AutoTransparency">
            <summary>
            sets transparency
            </summary>
        </member>
        <member name="F:AutoTransparency.WantedTransparency">
            <summary>
            The transparency the object should have.
            </summary>
        </member>
        <member name="F:AutoTransparency.FalloffTime">
            <summary>
            Time in seconds until which 100% visibility is restored.
            </summary>
        </member>
        <member name="F:AutoTransparency.oldShader">
            <summary>
            Save old shader of object.
            </summary>
        </member>
        <member name="F:AutoTransparency.oldColor">
            <summary>
            Save old color of object
            </summary>
        </member>
        <member name="F:AutoTransparency.transparency">
            <summary>
            Current transparency.
            </summary>
        </member>
        <member name="M:AutoTransparency.Start">
            <summary>
            Use this for initialization.
            </summary>
        </member>
        <member name="M:AutoTransparency.BeTransparent">
            <summary>
            Makes the object transparent.
            </summary>
        </member>
        <member name="M:AutoTransparency.Update">
            <summary>
            Update is called once per frame.
            </summary>
        </member>
        <member name="T:ActionAnimate">
            <summary>
            Action for animating a game object
            </summary>
        </member>
        <member name="T:ActionGeneric">
            <summary>
            Used for ad-hoc creation of actions
            </summary>
        </member>
        <member name="M:ActionGeneric.OnStart">
            <summary>
            Virtual method to implement IAction
            </summary>
        </member>
        <member name="M:ActionGeneric.OnFinish">
            <summary>
            Virtual method to implement IAction
            </summary>
        </member>
        <member name="M:ActionGeneric.OnUpdate">
            <summary>
            Virtual method to implement IAction
            </summary>
        </member>
        <member name="M:ActionGeneric.GUI">
            <summary>
            Virtual method to implement IAction
            </summary>
        </member>
        <member name="M:ActionGeneric.Finished">
            <summary>
            Necessary function
            </summary>
            <returns>if finished</returns>
        </member>
        <member name="F:ActionAnimate.gameObject">
            <summary>
            The game object to animate
            </summary>
        </member>
        <member name="F:ActionAnimate.animation">
            <summary>
            The name of the animation to change
            </summary>
        </member>
        <member name="F:ActionAnimate.state">
            <summary>
            The state the animation should be changed to
            </summary>
        </member>
        <member name="M:ActionAnimate.#ctor(UnityEngine.GameObject,System.String,System.Int32)">
            <summary>
            Constructor of object
            </summary>
            <param name="gameObject">The game object to animate</param>
            <param name="animation">The name of the animation to change</param>
            <param name="state">The state the animation should be changed to</param>
        </member>
        <member name="M:ActionAnimate.OnStart">
            <summary>
            Called when the action is dequeued
            </summary>
        </member>
        <member name="M:ActionAnimate.Finished">
            <summary>
            Called when finished
            </summary>
            <returns>Always return true.</returns>
        </member>
        <member name="T:ActionInstantiate">
            <summary>
            Instantiates a game object in the movement manager
            </summary>
        </member>
        <member name="F:ActionInstantiate.gameObject">
            <summary>
            Object to instantiate
            </summary>
        </member>
        <member name="F:ActionInstantiate.position">
            <summary>
            The position of the newly instantiated object
            </summary>
        </member>
        <member name="F:ActionInstantiate.rotation">
            <summary>
            The rotation of the newly instantiated object
            </summary>
        </member>
        <member name="M:ActionInstantiate.#ctor(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Constructor of object
            </summary>
            <param name="gameObject">game object to instantiate</param>
            <param name="position">the position</param>
            <param name="rotation">the rotation</param>
        </member>
        <member name="M:ActionInstantiate.OnStart">
            <summary>
            Called on start, instantiates the given game object
            </summary>
        </member>
        <member name="M:ActionInstantiate.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionLoadScene">
            <summary>
            Action for loading a new scene from a cutscene
            </summary>
        </member>
        <member name="F:ActionLoadScene.levelName">
            <summary>
            Name of the level to load
            </summary>
        </member>
        <member name="M:ActionLoadScene.#ctor(System.String)">
            <summary>
            Constructor of object
            </summary>
            <param name="levelName">Name of the level to load</param>
        </member>
        <member name="M:ActionLoadScene.OnStart">
            <summary>
            Called on start
            </summary>
        </member>
        <member name="M:ActionLoadScene.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionMoveTo">
            <summary>
            moves towards something
            </summary>
        </member>
        <member name="F:ActionMoveTo.relative">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:ActionMoveTo.duration">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:ActionMoveTo.remaining">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:ActionMoveTo.start">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:ActionMoveTo.to">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="F:ActionMoveTo.gameObject">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="M:ActionMoveTo.#ctor(UnityEngine.GameObject,UnityEngine.Vector3,System.Single,System.Boolean)">
            <summary>
            some constructor
            </summary>
            <param name="gameObject">game object</param>
            <param name="to">to where</param>
            <param name="duration">over time</param>
            <param name="relative">whether relative</param>
        </member>
        <member name="M:ActionMoveTo.#ctor(UnityEngine.GameObject,UnityEngine.Vector3,System.Single)">
            <summary>
            some constructor
            </summary>
            <param name="gameObject">game object</param>
            <param name="to">to where</param>
            <param name="duration">over time</param>
        </member>
        <member name="M:ActionMoveTo.#ctor(UnityEngine.GameObject,UnityEngine.Vector3)">
            <summary>
            some constructor
            </summary>
            <param name="gameObject">game object</param>
            <param name="to">to where</param>
        </member>
        <member name="M:ActionMoveTo.OnStart">
            <summary>
            some callback
            </summary>
        </member>
        <member name="M:ActionMoveTo.OnFinish">
            <summary>
            some callback
            </summary>
        </member>
        <member name="M:ActionMoveTo.OnUpdate">
            <summary>
            some callback
            </summary>
        </member>
        <member name="M:ActionMoveTo.GUI">
            <summary>
            some callback
            </summary>
        </member>
        <member name="M:ActionMoveTo.Finished">
            <summary>
            some callback
            </summary>
            <returns>if finished</returns>
        </member>
        <member name="T:ActionRemove">
            <summary>
            Action used to remove an object
            </summary>
        </member>
        <member name="F:ActionRemove.gameObject">
            <summary>
            Game object to remove
            </summary>
        </member>
        <member name="M:ActionRemove.#ctor(UnityEngine.GameObject)">
            <summary>
            Constructor of objects
            </summary>
            <param name="gameObject">game object to remove</param>
        </member>
        <member name="M:ActionRemove.OnStart">
            <summary>
            Destroys the object on start
            </summary>
        </member>
        <member name="M:ActionRemove.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionReset">
            <summary>
            Action to reset the cutscene manager
            </summary>
        </member>
        <member name="F:ActionReset.movementManager">
            <summary>
            The movement manager to reset
            </summary>
        </member>
        <member name="M:ActionReset.#ctor(MovementManager)">
            <summary>
            Constructor of object
            </summary>
            <param name="man">The movement manager to reset</param>
        </member>
        <member name="M:ActionReset.OnStart">
            <summary>
            On start reset the movement manager
            </summary>
        </member>
        <member name="M:ActionReset.OnFinish">
            <summary>
            Prevent it from running
            </summary>
        </member>
        <member name="M:ActionReset.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionRotate">
            <summary>
            Action to rotate a game object
            </summary>
        </member>
        <member name="F:ActionRotate.gameObject">
            <summary>
            The game object to rotate
            </summary>
        </member>
        <member name="F:ActionRotate.rotation">
            <summary>
            The rotation to perform
            </summary>
        </member>
        <member name="F:ActionRotate.start">
            <summary>
            The start of the rotation
            </summary>
        </member>
        <member name="F:ActionRotate.direction">
            <summary>
            The direction of the rotation
            </summary>
        </member>
        <member name="F:ActionRotate.duration">
            <summary>
            The duration of the rotation (in sec)
            </summary>
        </member>
        <member name="F:ActionRotate.remaining">
            <summary>
            The remaining seconds of the rotation
            </summary>
        </member>
        <member name="M:ActionRotate.#ctor(UnityEngine.GameObject,UnityEngine.Vector3,System.Single)">
            <summary>
            Constructor of object
            </summary>
            <param name="gameObject">The game object to rotate</param>
            <param name="rotation">The rotation to perform</param>
            <param name="duration">The duration of the rotation (in sec)</param>
        </member>
        <member name="M:ActionRotate.OnStart">
            <summary>
            Called on start
            </summary>
        </member>
        <member name="M:ActionRotate.OnUpdate">
            <summary>
            Called every frame
            </summary>
        </member>
        <member name="M:ActionRotate.Finished">
            <summary>
            Calculates if we are finished
            </summary>
            <returns>True when remaining le 0</returns>
        </member>
        <member name="T:ActionScale">
            <summary>
            Action to scale a game object
            </summary>
        </member>
        <member name="F:ActionScale.gameObject">
            <summary>
            The game object to scale
            </summary>
        </member>
        <member name="F:ActionScale.scale">
            <summary>
            The scale
            </summary>
        </member>
        <member name="F:ActionScale.relative">
            <summary>
            The relative scale
            </summary>
        </member>
        <member name="F:ActionScale.duration">
            <summary>
            The duration in sec
            </summary>
        </member>
        <member name="F:ActionScale.remaining">
            <summary>
            The remaining seconds
            </summary>
        </member>
        <member name="M:ActionScale.#ctor(UnityEngine.Transform,UnityEngine.Vector3,System.Single)">
            <summary>
            Constructor of object
            </summary>
            <param name="gameObject">The game object to scale</param>
            <param name="scale">The scale vector</param>
            <param name="duration">The duration</param>
        </member>
        <member name="M:ActionScale.OnStart">
            <summary>
            Called on start
            calculates the relative scale
            </summary>
        </member>
        <member name="M:ActionScale.OnUpdate">
            <summary>
            Calculates the new scale
            </summary>
        </member>
        <member name="M:ActionScale.Finished">
            <summary>
            Returns if the action is finished
            </summary>
            <returns>True if remaining le 0</returns>
        </member>
        <member name="T:ActionSetCutscene">
            <summary>
            Action to set isCutscene in Game
            </summary>
        </member>
        <member name="F:ActionSetCutscene.value">
            <summary>
            Value to set Game.isCutscene to
            </summary>
        </member>
        <member name="F:ActionSetCutscene.ignore">
            <summary>
            Ignore the black bars
            </summary>
        </member>
        <member name="M:ActionSetCutscene.#ctor(System.Boolean)">
            <summary>
            Constructor of object
            </summary>
            <param name="to">Value to set Game.isCutscene to</param>
        </member>
        <member name="M:ActionSetCutscene.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Constructor of object
            </summary>
            <param name="to">Value to set Game.isCutscene to</param>
            <param name="ignore">Disable the black bars</param>
        </member>
        <member name="M:ActionSetCutscene.OnStart">
            <summary>
            Called on start
            </summary>
        </member>
        <member name="M:ActionSetCutscene.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionSetKinematic">
            <summary>
            Enables or disables kinematic movement for an object
            </summary>
        </member>
        <member name="F:ActionSetKinematic.obj">
            <summary>
            Object to set
            </summary>
        </member>
        <member name="F:ActionSetKinematic.value">
            <summary>
            Value to set isKinematic to
            </summary>
        </member>
        <member name="M:ActionSetKinematic.#ctor(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Constructor of object
            </summary>
            <param name="gameObject">An object with a Rigidbody</param>
            <param name="to">Value to set isKinematic to</param>
        </member>
        <member name="M:ActionSetKinematic.OnStart">
            <summary>
            Called, when the action is dequeued
            </summary>
        </member>
        <member name="M:ActionSetKinematic.Finished">
            <summary>
            Should return true when the action should be removed
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionSetLookAt">
            <summary>
            Action to let object look at each other
            </summary>
        </member>
        <member name="F:ActionSetLookAt.me">
            <summary>
            The game object to rotate
            </summary>
        </member>
        <member name="F:ActionSetLookAt.coord">
            <summary>
            The coordinates to look at
            </summary>
        </member>
        <member name="M:ActionSetLookAt.#ctor(UnityEngine.GameObject,UnityEngine.Vector3)">
            <summary>
            Constructor of object
            </summary>
            <param name="me">The game object to rotate</param>
            <param name="coord">The coordinates to look at</param>
        </member>
        <member name="M:ActionSetLookAt.OnStart">
            <summary>
            Called on start
            </summary>
        </member>
        <member name="M:ActionSetLookAt.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionSetRenderer">
            <summary>
            renders stuff
            </summary>
        </member>
        <member name="F:ActionSetRenderer.renderer">
            <summary>
            The renderer to manipulate
            </summary>
        </member>
        <member name="F:ActionSetRenderer.value">
            <summary>
            The value to set the renderer to
            </summary>
        </member>
        <member name="M:ActionSetRenderer.#ctor(UnityEngine.Renderer,System.Boolean)">
            <summary>
            Constructor of object
            </summary>
            <param name="renderer">The renderer to manipulate</param>
            <param name="value">The value to set the renderer to</param>
        </member>
        <member name="M:ActionSetRenderer.OnStart">
            <summary>
            Set the renderer
            </summary>
        </member>
        <member name="M:ActionSetRenderer.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionShowMessage">
            <summary>
            Action to show a message on the screen
            </summary>
        </member>
        <member name="F:ActionShowMessage.message">
            <summary>
            The message to show
            </summary>
        </member>
        <member name="M:ActionShowMessage.#ctor(System.String)">
            <summary>
            Constructor of object
            </summary>
            <param name="message">Message to show</param>
        </member>
        <member name="M:ActionShowMessage.OnStart">
            <summary>
            On start show message
            </summary>
        </member>
        <member name="M:ActionShowMessage.Finished">
            <summary>
            Immediately finished
            </summary>
            <returns>always true</returns>
        </member>
        <member name="T:ActionSleep">
            <summary>
            Enables the MovementManager to sleep an amount of time
            </summary>
        </member>
        <member name="F:ActionSleep.sleep">
            <summary>
            Saves the remaining seconds to sleep
            </summary>
        </member>
        <member name="M:ActionSleep.#ctor(System.Single)">
            <summary>
            Constructor for Sleep
            </summary>
            <param name="seconds">The number of seconds to sleep</param>
        </member>
        <member name="M:ActionSleep.OnUpdate">
            <summary>
            Called every frame
            </summary>
        </member>
        <member name="M:ActionSleep.Finished">
            <summary>
            Called to determine if the sequence is finished and should be dequeued
            </summary>
            <returns>True if it should be removed</returns>
        </member>
        <member name="T:ActionTranslate">
            <summary>
            Action to move objects
            </summary>
        </member>
        <member name="F:ActionTranslate.relative">
            <summary>
            Relative movement
            </summary>
        </member>
        <member name="F:ActionTranslate.duration">
            <summary>
            The duration in seconds
            </summary>
        </member>
        <member name="F:ActionTranslate.remaining">
            <summary>
            The remaining time in seconds
            </summary>
        </member>
        <member name="F:ActionTranslate.start">
            <summary>
            Start of the movement
            </summary>
        </member>
        <member name="F:ActionTranslate.to">
            <summary>
            Goal of the movement
            </summary>
        </member>
        <member name="F:ActionTranslate.gameObject">
            <summary>
            Game object to translate
            </summary>
        </member>
        <member name="M:ActionTranslate.#ctor(UnityEngine.GameObject,UnityEngine.Vector3,System.Single,System.Boolean)">
            <summary>
            Construction of object
            </summary>
            <param name="gameObject">Game object to translate</param>
            <param name="to">Goal of the movement</param>
            <param name="duration">The duration in seconds</param>
            <param name="relative">Relative movement</param>
        </member>
        <member name="M:ActionTranslate.#ctor(UnityEngine.GameObject,UnityEngine.Vector3,System.Single)">
            <summary>
            More easy translation
            </summary>
            <param name="gameObject">>Game object to translate</param>
            <param name="to">Goal of the movement</param>
            <param name="duration">The duration in seconds</param>
        </member>
        <member name="M:ActionTranslate.#ctor(UnityEngine.GameObject,UnityEngine.Vector3)">
            <summary>
            Constructor of object
            </summary>
            <param name="gameObject">>Game object to translate</param>
            <param name="to">Goal of the movement</param>
        </member>
        <member name="M:ActionTranslate.OnStart">
            <summary>
            Called on start
            </summary>
        </member>
        <member name="M:ActionTranslate.OnUpdate">
            <summary>
            Called every frame
            </summary>
        </member>
        <member name="M:ActionTranslate.Finished">
            <summary>
            Finished when done
            </summary>
            <returns>True if remaining is not greater than 0</returns>
        </member>
        <member name="T:PauseScreen">
            <summary>
            Class for a basic pause screen
            </summary>
        </member>
        <member name="F:PauseScreen.isPaused">
            <summary>
            True if the game is paused
            </summary>
        </member>
        <member name="F:PauseScreen.background">
            <summary>
            The texture to show as background
            </summary>
        </member>
        <member name="M:PauseScreen.Start">
            <summary>
            Called when the Object is instantiated
            </summary>
        </member>
        <member name="M:PauseScreen.Update">
            <summary>
            Called in every frame
            </summary>
        </member>
        <member name="M:PauseScreen.OnGUI">
            <summary>
            Called when the GUI should be drawn
            </summary>
        </member>
        <member name="T:Projectile">
            <summary>
            Basic projectile class. 
            
            Bullet moves into Y direction of the object and can hit both player and enemies, depending on the faction set.
            The bullet will only hit things that are hostile to the bullet's faction OR that are targeted "Hittable" (for stationary targets,  f.e.)
            Has to be applied onto a rigid body and is removed after hitting something.
            </summary>
        </member>
        <member name="F:Projectile.damage">
            <summary>
            Damage the bullet does to the player/enemy
            </summary>
        </member>
        <member name="F:Projectile.damagePerIntervall">
            <summary>
            Amount of damage dealt per interval. For more information see IHitable.
            </summary>
        </member>
        <member name="F:Projectile.damageIntervallLength">
            <summary>
            Time until the damage stops. For more information see IHitable.
            </summary>
        </member>
        <member name="F:Projectile.damageTime">
            <summary>
            Interval in which damage is dealt
            </summary>
        </member>
        <member name="F:Projectile.speed">
            <summary>
            Speed of the bullet. Bullet moves into Y direction of the object.
            </summary>
        </member>
        <member name="F:Projectile.maxTimeAlive">
            <summary>
            Time until the bullet gets destroyed.
            
            Defaults to 10 seconds if not set.
            </summary>
        </member>
        <member name="F:Projectile.timeOfCreation">
            <summary>
            Timestamp of the creation of the bullet, used for deleting the bullet after a certain time
            </summary>
        </member>
        <member name="F:Projectile.faction">
            <summary>
            the bullet belongs to a faction and will hit only other factions
            set to "NONE" if you want to hit anything
            </summary>
        </member>
        <member name="F:Projectile.hitPrefab">
            <summary>
            When something is hit, one object of HitPrefab is created at
            the position of the bullet.
            </summary>
        </member>
        <member name="M:Projectile.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:Projectile.Update">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:Projectile.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            Called by Unity.
            Damages every CommonEntity of other faction OR every "Hitable"-tagged object that implements IHitable
            Bullet is removed after hit.
            </summary>
            <param name="collider">Set by Unity</param>
        </member>
        <member name="T:Puzzle1Platform">
            <summary>
            some puzzle
            </summary>
        </member>
        <member name="F:Puzzle1Platform.canMove">
            <summary>
            if can move
            </summary>
        </member>
        <member name="F:Puzzle1Platform.bla">
            <summary>
            what the flying fuck is this
            </summary>
        </member>
        <member name="F:Puzzle1Platform.isMoving">
            <summary>
            whether moving
            </summary>
        </member>
        <member name="F:Puzzle1Platform.lastDir">
            <summary>
            last direction
            </summary>
        </member>
        <member name="F:Puzzle1Platform.dir">
            <summary>
            another direction?
            </summary>
        </member>
        <member name="M:Puzzle1Platform.OnCollisionEnter(UnityEngine.Collision)">
            <summary>
            Unity Callback
            </summary>
            <param name="collision">some collision</param>
        </member>
        <member name="M:Puzzle1Platform.Moving(System.String)">
            <summary>
            while moving
            </summary>
            <param name="direction">into where</param>
        </member>
        <member name="M:Puzzle1Platform.Start">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="M:Puzzle1Platform.Update">
            <summary>
            Unity Callback
            </summary>
        </member>
        <member name="T:Remove">
            <summary>
            removed all connected objects by Trigger
            </summary>
        </member>
        <member name="F:Remove.objekts">
            <summary>
            objects which will removed
            </summary>
        </member>
        <member name="M:Remove.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            called when triggered
            </summary>
            <param name="by">by who</param>
            <param name="isTriggered">whether triggered</param>
        </member>
        <member name="T:GameData">
            <summary>
            definition of save game data
            </summary>
        </member>
        <member name="F:GameData.igor">
            <summary>
            the igor
            </summary>
        </member>
        <member name="F:GameData.scene">
            <summary>
            scene name
            </summary>
        </member>
        <member name="F:GameData.prefabs">
            <summary>
            all prefabs
            </summary>
        </member>
        <member name="F:GameData.chests">
            <summary>
            all chests
            </summary>
        </member>
        <member name="F:GameData.enemies">
            <summary>
            all enemies
            </summary>
        </member>
        <member name="F:GameData.boss">
            <summary>
            store boss data
            </summary>
        </member>
        <member name="F:GameData.transformers">
            <summary>
            store transformers
            </summary>
        </member>
        <member name="F:GameData.cutscenes">
            <summary>
            all cut scenes
            </summary>
        </member>
        <member name="F:GameData.jeveData">
            <summary>
            store Jeve data
            </summary>
        </member>
        <member name="F:GameData.skillBarData">
            <summary>
            skill bar stuff
            </summary>
        </member>
        <member name="F:GameData.skillData">
            <summary>
            skill stuff
            </summary>
        </member>
        <member name="F:GameData.gameDifficulty">
            <summary>
            the difficulty of game
            </summary>
        </member>
        <member name="M:GameData.#ctor(GameData.Operation)">
            <summary>
            GameData constructor with operation
            operation.SAVE: use it if save game
            operation.LOAD: use it if load game
            </summary>
            <param name="op">SAVE/LOAD or not SAVE/LOAD</param>
        </member>
        <member name="M:GameData.#ctor">
            <summary>
            null constructor for GameData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="T:GameData.Operation">
            <summary>
            what to do
            </summary>
        </member>
        <member name="F:GameData.Operation.SAVE">
            <summary>
            Save the game.
            </summary>
        </member>
        <member name="F:GameData.Operation.LOAD">
            <summary>
            Load the game.
            </summary>
        </member>
        <member name="T:GameData.IgorData">
            <summary>
            class that stores igor data
            </summary>
        </member>
        <member name="F:GameData.IgorData.igor1Position">
            <summary>
            igor1 prefab position
            </summary>
        </member>
        <member name="F:GameData.IgorData.igor1Rotation">
            <summary>
            igor1 prefab rotation
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorPosition">
            <summary>
            igor position
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorRotation">
            <summary>
            igor rotation
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorLevel">
            <summary>
            igor level
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorExperience">
            <summary>
            igor experience
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorHealthPoints">
            <summary>
            igor health points
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorMaxHealthPoints">
            <summary>
            igor max health point
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorSpeed">
            <summary>
            igor speed
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorMana">
            <summary>
            igor mana
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorMaxMana">
            <summary>
            igor max mana
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorHealthRegeneration">
            <summary>
            igor health regeneration
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorManaRegeneration">
            <summary>
            igor mana regeneration
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorSkillpoints">
            <summary>
            igor skill points
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorDamageOverTimeEffects">
            <summary>
            igor damage over time effects
            </summary>
        </member>
        <member name="F:GameData.IgorData.igorInventory">
            <summary>
            the InventoryRecover list for save igor inventory
            </summary>
        </member>
        <member name="M:GameData.IgorData.IgorInventoryReader">
            <summary>
            read igor's inventory data
            </summary>
            <returns>InventoryRecover list</returns>
        </member>
        <member name="M:GameData.IgorData.#ctor">
            <summary>
            null constructor for IgorData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.IgorData.#ctor(GameData.Operation)">
            <summary>
            IgorData constructor with operation
            operation.SAVE: use it if save game
            operation.LOAD: use it if load game
            </summary>
            <param name="op">SAVE/LOAD or not SAVE/LOAD</param>
        </member>
        <member name="T:GameData.IgorData.InventoryRecover">
            <summary>
            definition the igor's inventory
            </summary>
        </member>
        <member name="F:GameData.IgorData.InventoryRecover.amount">
            <summary>
            the item amount of one slot
            </summary>
        </member>
        <member name="F:GameData.IgorData.InventoryRecover.name">
            <summary>
            the item name of one slot
            </summary>
        </member>
        <member name="F:GameData.IgorData.InventoryRecover.repairKitAmountToHeal">
            <summary>
            how many hp a repairKit can repair
            </summary>
        </member>
        <member name="M:GameData.IgorData.InventoryRecover.#ctor(System.Int32,System.String,Inventory.InventoryItem)">
            <summary>
            the constructor for InventoryRecover
            </summary>
            <param name="stacks">InventoryItem stacks</param>
            <param name="iInvItemName">InventoryItem name</param>
            <param name="item">InventoryItem instance</param>
        </member>
        <member name="M:GameData.IgorData.InventoryRecover.#ctor">
            <summary>
            null constructor for InventoryRecover
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="T:GameData.SkillBarData">
            <summary>
            structure to save skill bar
            </summary>
        </member>
        <member name="F:GameData.SkillBarData.slotList">
            <summary>
            the SkillSlot list for saving SkillBar slot
            </summary>
        </member>
        <member name="M:GameData.SkillBarData.#ctor">
            <summary>
            null constructor of SkillBarData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.SkillBarData.#ctor(GameData.Operation)">
            <summary>
            constructor of SkillBarData,using in save game
            </summary>
            <param name="op">operation : Operation.SAVE or Operation.LOAD </param>
        </member>
        <member name="T:GameData.SkillBarData.SkillSlot">
            <summary>
            saving of a skill slot
            </summary>
        </member>
        <member name="F:GameData.SkillBarData.SkillSlot.index">
            <summary>
            the index of SkillBar slot
            </summary>
        </member>
        <member name="F:GameData.SkillBarData.SkillSlot.name">
            <summary>
            the name of SkillBar slot
            </summary>
        </member>
        <member name="F:GameData.SkillBarData.SkillSlot.type">
            <summary>
            the type of SkillBar slot
            </summary>
        </member>
        <member name="M:GameData.SkillBarData.SkillSlot.#ctor">
            <summary>
            null constructor of SkillSlot
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.SkillBarData.SkillSlot.#ctor(System.String,System.Int32)">
            <summary>
            the constructor of SkillSlot
            </summary>
            <param name="skillName">the name of slot</param>
            <param name="skillIndex">the index of slot</param>
        </member>
        <member name="M:GameData.SkillBarData.SkillSlot.#ctor(System.String,SkillBar.SkillBarItem.ItemType,System.Int32)">
            <summary>
            the constructor of SkillSlot
            </summary>
            <param name="skillName">the name of slot</param>
            <param name="skillType">the type of slot</param>
            <param name="skillIndex">the index of slot</param>
        </member>
        <member name="T:GameData.SkillData">
            <summary>
            class to save skill data
            </summary>
        </member>
        <member name="F:GameData.SkillData.skillDataList">
            <summary>
            SkillDataList to save skill data
            </summary>
        </member>
        <member name="M:GameData.SkillData.#ctor">
            <summary>
            null constructor for SkillData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.SkillData.#ctor(System.Collections.Generic.List{Skills.SkillData})">
            <summary>
            constructor of SkillData
            </summary>
            <param name="skills">Skills.SkillData for Skills class</param>
        </member>
        <member name="T:GameData.SkillData.SkillDataList">
            <summary>
            saves skill data
            </summary>
        </member>
        <member name="F:GameData.SkillData.SkillDataList.skillName">
            <summary>
            the name of skill
            </summary>
        </member>
        <member name="F:GameData.SkillData.SkillDataList.skillLevel">
            <summary>
            the level of skill
            </summary>
        </member>
        <member name="M:GameData.SkillData.SkillDataList.#ctor">
            <summary>
            null constructor for SkillDataList
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.SkillData.SkillDataList.#ctor(System.String,System.Int32)">
            <summary>
            constructor for SkillDataList
            </summary>
            <param name="name">for skill</param>
            <param name="level">for level</param>
        </member>
        <member name="T:GameData.ScenePrefab">
            <summary>
            the class of prefab in scene without igor,enemies
            </summary>
        </member>
        <member name="F:GameData.ScenePrefab.prefabPosition">
            <summary>
            the position of prefab
            </summary>
        </member>
        <member name="F:GameData.ScenePrefab.prefabRotation">
            <summary>
            the rotation of prefab
            </summary>
        </member>
        <member name="F:GameData.ScenePrefab.prefabName">
            <summary>
            the name of prefab
            </summary>
        </member>
        <member name="F:GameData.ScenePrefab.prefabAttribute1">
            <summary>
            attribute of prefab
            if the instance prefab has more attribute,please add in here
            </summary>
        </member>
        <member name="F:GameData.ScenePrefab.prefabAttribute2">
            <summary>
            attribute of prefab
            if the instance prefab has more attribute,please add in here
            </summary>
        </member>
        <member name="M:GameData.ScenePrefab.#ctor">
            <summary>
            null constructor of ScenePrefab
            -- Attention: the null constructor is very important for serialization!! --
            </summary>
        </member>
        <member name="M:GameData.ScenePrefab.#ctor(UnityEngine.GameObject)">
            <summary>
            the prefab object
            </summary>
            <param name="obj">game object that want to be saved</param>
        </member>
        <member name="T:GameData.ChestData">
            <summary>
            class to save chest data
            </summary>
        </member>
        <member name="F:GameData.ChestData.chestPosition">
            <summary>
            the position of chest
            </summary>
        </member>
        <member name="F:GameData.ChestData.chestRotation">
            <summary>
            the rotation of chest
            </summary>
        </member>
        <member name="F:GameData.ChestData.isChestOpened">
            <summary>
            whether a chest is opened
            </summary>
        </member>
        <member name="F:GameData.ChestData.ChestItemsName">
            <summary>
            the item names that chest contain
            </summary>
        </member>
        <member name="F:GameData.ChestData.chestName">
            <summary>
            the name of chest object
            </summary>
        </member>
        <member name="M:GameData.ChestData.#ctor">
            <summary>
            null constructor for ChestData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.ChestData.#ctor(UnityEngine.GameObject)">
            <summary>
            constructor of ChestData
            </summary>
            <param name="obj">the chest object</param>
        </member>
        <member name="T:GameData.EnemyPrefab">
            <summary>
            the class of enemy
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyName">
            <summary>
            the name of EnemyPrefab
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyPosition">
            <summary>
            the position of EnemyPrefab
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyRotation">
            <summary>
            the rotation of EnemyPrefab
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyHealthPoints">
            <summary>
            the hp of EnemyPrefab
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyNavMeshTransformsPosition">
            <summary>
            the way point information of EnemyPrefab
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyCurrentWaypoint">
            <summary>
            the current way point of EnemyPrefab
            </summary>
        </member>
        <member name="F:GameData.EnemyPrefab.enemyCurrentFaction">
            <summary>
            the faction of EnemyPrefab
            </summary>
        </member>
        <member name="M:GameData.EnemyPrefab.#ctor">
            <summary>
            null constructor for EnemyPrefab
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.EnemyPrefab.#ctor(UnityEngine.GameObject)">
            <summary>
            constructor of EnemyPrefab
            </summary>
            <param name="obj">EnemyPrefab object </param>
        </member>
        <member name="T:GameData.BossData">
            <summary>
            store boss data
            </summary>
        </member>
        <member name="F:GameData.BossData.bossPosition">
            <summary>
            store boss position
            </summary>
        </member>
        <member name="F:GameData.BossData.bossRotation">
            <summary>
            store boss rotation
            </summary>
        </member>
        <member name="F:GameData.BossData.bossHP">
            <summary>
            store boss HP
            </summary>
        </member>
        <member name="M:GameData.BossData.#ctor">
            <summary>
            null constructor for BossData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.BossData.#ctor(UnityEngine.GameObject)">
            <summary>
            constructor for BossData
            </summary>
            <param name="obj">boss object</param>
        </member>
        <member name="T:GameData.BossTransformerData">
            <summary>
            store boss transformer data
            </summary>
        </member>
        <member name="F:GameData.BossTransformerData.transformerPosition">
            <summary>
            store transformer position
            </summary>
        </member>
        <member name="F:GameData.BossTransformerData.transformerState">
            <summary>
            store transformer state
            </summary>
        </member>
        <member name="M:GameData.BossTransformerData.#ctor">
            <summary>
            null constructor for BossTransformerData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.BossTransformerData.#ctor(UnityEngine.GameObject)">
            <summary>
            constructor of BossTransformerData
            </summary>
            <param name="obj">transformer obj</param>
        </member>
        <member name="T:GameData.CutscenePrefab">
            <summary>
            save cutscene data 
            </summary>
        </member>
        <member name="F:GameData.CutscenePrefab.cutscenePrefabInitialPosition">
            <summary>
            the InitialPosition of CutscenePrefab
            </summary>
        </member>
        <member name="F:GameData.CutscenePrefab.cutscenePrefabCurrentPosition">
            <summary>
            the CurrentPosition of CutscenePrefab
            </summary>
        </member>
        <member name="F:GameData.CutscenePrefab.cutscenePrefabIsRunned">
            <summary>
            whether the cutscene is ran
            </summary>
        </member>
        <member name="M:GameData.CutscenePrefab.#ctor">
            <summary>
            null constructor of CutscenePrefab
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.CutscenePrefab.#ctor(UnityEngine.GameObject)">
            <summary>
            constructor of CutscenePrefab
            </summary>
            <param name="obj">the object</param>
        </member>
        <member name="T:GameData.CutscenePrefabJeveData">
            <summary>
            store cutscene Jeve data
            </summary>
        </member>
        <member name="F:GameData.CutscenePrefabJeveData.jevePosition">
            <summary>
            store Jeve position
            </summary>
        </member>
        <member name="F:GameData.CutscenePrefabJeveData.jeveRotation">
            <summary>
            store Jeve rotation
            </summary>
        </member>
        <member name="M:GameData.CutscenePrefabJeveData.#ctor">
            <summary>
            null constructor for GameDifficultyData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.CutscenePrefabJeveData.#ctor(UnityEngine.GameObject)">
            <summary>
            constructor of GameDifficultyData
            </summary>
            <param name="obj">the Jeve object</param>
        </member>
        <member name="T:GameData.GameDifficultyData">
            <summary>
            save currentDifficulty data
            </summary>
        </member>
        <member name="F:GameData.GameDifficultyData.difficulty">
            <summary>
            currentDifficulty data
            </summary>
        </member>
        <member name="M:GameData.GameDifficultyData.#ctor">
            <summary>
            null constructor for GameDifficultyData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameData.GameDifficultyData.#ctor(Game.Difficulty)">
            <summary>
            constructor of GameDifficultyData
            </summary>
            <param name="dif">Game.Difficulty type object</param>
        </member>
        <member name="T:GameDataManager">
            <summary>
            manages game data
            </summary>
        </member>
        <member name="F:GameDataManager.gameData">
            <summary>
            the GameData instance should be saved
            </summary>
        </member>
        <member name="F:GameDataManager.saveLoadDatas">
            <summary>
            ten save / load slot
            </summary>
        </member>
        <member name="F:GameDataManager.hasSwapDate">
            <summary>
            whether exist the swap data
            </summary>
        </member>
        <member name="F:GameDataManager.loadGameDate">
            <summary>
            the GameData instance should be loaded
            </summary>
        </member>
        <member name="F:GameDataManager.gdr">
            <summary>
            GameDataRecover instance for recover game
            </summary>
        </member>
        <member name="F:GameDataManager.sd">
            <summary>
            the swap data used for change scene
            </summary>
        </member>
        <member name="M:GameDataManager.Awake">
            <summary>
            call by Unity
            </summary>
        </member>
        <member name="M:GameDataManager.Start">
            <summary>
            call by Unity
            </summary>
        </member>
        <member name="M:GameDataManager.Save(System.String)">
            <summary>
            save a game state
            </summary>
            <param name="fileName">the name of save file</param>
        </member>
        <member name="M:GameDataManager.Load(System.String)">
            <summary>
            load a game state
            </summary>
            <param name="fileName">the name of file</param>
            <returns>a GameData object </returns>
        </member>
        <member name="M:GameDataManager.Update">
            <summary>
            call by Unity
            </summary>
        </member>
        <member name="F:GameDataManager.isPaused">
            <summary>
            whether the game is paused
            </summary>
        </member>
        <member name="F:GameDataManager.isMainMenu">
            <summary>
            whether in MainMenu
            </summary>
        </member>
        <member name="F:GameDataManager.isSaveMenu">
            <summary>
            whether in SaveMenu
            </summary>
        </member>
        <member name="F:GameDataManager.isLoadMenu">
            <summary>
            whether in LoadMenu
            </summary>
        </member>
        <member name="M:GameDataManager.OnGUI">
            <summary>
            GUI of save menu
            </summary>
        </member>
        <member name="F:GameDataManager.showData">
            <summary>
            the save/load slot show
            </summary>
        </member>
        <member name="T:GameDataManager.SwapData">
            <summary>
            swaps data
            </summary>
        </member>
        <member name="F:GameDataManager.SwapData.initializeLoad">
            <summary>
            whether load a game stand when this class be initialized
            </summary>
        </member>
        <member name="F:GameDataManager.SwapData.loadDataPath">
            <summary>
            the path of file that should be loaded
            </summary>
        </member>
        <member name="M:GameDataManager.SwapData.#ctor">
            <summary>
            null constructor of SwapData
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameDataManager.SwapData.#ctor(System.Boolean,System.String)">
            <summary>
            constructor of SwapData
            </summary>
            <param name="iLoad">whether load when initialized</param>
            <param name="path">path of file.</param>
        </member>
        <member name="T:GameDataManager.SaveLoadDataShow">
            <summary>
            show save data in the GUI
            </summary>
        </member>
        <member name="F:GameDataManager.SaveLoadDataShow.indexNum">
            <summary>
            the slot number
            </summary>
        </member>
        <member name="F:GameDataManager.SaveLoadDataShow.sceneName">
            <summary>
            the scene name of saved data
            </summary>
        </member>
        <member name="F:GameDataManager.SaveLoadDataShow.igorLevel">
            <summary>
            the igor level of saved data
            </summary>
        </member>
        <member name="F:GameDataManager.SaveLoadDataShow.saveTime">
            <summary>
            the saving time of a save data
            </summary>
        </member>
        <member name="M:GameDataManager.SaveLoadDataShow.#ctor">
            <summary>
            null constructor of SaveLoadDataShow
            Attention: the null constructor is very important for serialization!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            </summary>
        </member>
        <member name="M:GameDataManager.SaveLoadDataShow.#ctor(System.String)">
            <summary>
            constructor of SaveLoadDataShow
            </summary>
            <param name="str">the show string</param>
        </member>
        <member name="M:GameDataManager.SaveLoadDataShow.#ctor(GameData)">
            <summary>
            constructor of SaveLoadDataShow
            </summary>
            <param name="gd">the GameData</param>
        </member>
        <member name="T:GameDataRecover">
            <summary>
            loads games
            </summary>
        </member>
        <member name="M:GameDataRecover.#ctor">
            <summary>
            null constructor of GameDataRecover
            </summary>
        </member>
        <member name="M:GameDataRecover.#ctor(GameData)">
            <summary>
            constructor of GameDataRecover
            recover game state from a GameData object
            </summary>
            <param name="gd">the GameData object </param>
        </member>
        <member name="M:GameDataRecover.GameDifficultyDataRecover(GameData)">
            <summary>
            recover game difficulty data
            </summary>
            <param name="gd">GameData object </param>
        </member>
        <member name="M:GameDataRecover.LoadScene(System.String)">
            <summary>
            load game scene
            </summary>
            <param name="sceneName">name of the scene to load</param>
        </member>
        <member name="M:GameDataRecover.SkillBarRecover(GameData)">
            <summary>
            recover SkillBar
            </summary>
            <param name="gd">the GameData object that recover from </param>
        </member>
        <member name="M:GameDataRecover.SkillTreeRecover(GameData)">
            <summary>
            recover SkillTreeRecover
            </summary>
            <param name="gd">the GameData object that recover from </param>
        </member>
        <member name="M:GameDataRecover.ScenePrefabRecover(GameData)">
            <summary>
            recover prefabs and enemies
            </summary>
            <param name="gd">the GameData object that recover from </param>
        </member>
        <member name="M:GameDataRecover.BossDataRecover(GameData)">
            <summary>
            recover boss data
            </summary>
            <param name="gd">GameData object</param>
        </member>
        <member name="M:GameDataRecover.CutscenePrefabRecover(GameData)">
            <summary>
            recover cutscene information
            </summary>
            <param name="gd">the GameData object that recover from </param>
        </member>
        <member name="M:GameDataRecover.IgorRecover(GameData)">
            <summary>
            recover igor data from GameDataS
            </summary>
            <param name="gd"> the GameData used to recover </param>
        </member>
        <member name="M:GameDataRecover.GetIInvItemArrayList(System.Collections.Generic.List{GameData.IgorData.InventoryRecover})">
            <summary>
            recover InventoryItem from GameData
            if new item be inserted into this game ,please insert code for this item under "//ADD NEW ITEMS"
            </summary>
            <param name="list">some list</param>
            <returns>some array</returns>
        </member>
        <member name="T:XMLGameSaver">
            <summary>
            saves games into xml
            </summary>
        </member>
        <member name="M:XMLGameSaver.SerializeObject(System.Object)">
            <summary>
            serialize a object
            </summary>
            <param name="gObj">the object need to be serialized</param>
            <returns>serialized string</returns>
        </member>
        <member name="M:XMLGameSaver.DeserializeObject``1(System.String)">
            <summary>
            deserialize a object
            </summary>
            <typeparam name="T">some object type</typeparam>
            <param name="xmlString">some xml</param>
            <returns>more object type</returns>
        </member>
        <member name="M:XMLGameSaver.SaveGame(System.String,System.String,System.String)">
            <summary>
            save game into file
            </summary>
            <param name="fileLocation">location of file</param>
            <param name="fileName">file name</param>
            <param name="xmlData">game data</param>
        </member>
        <member name="M:XMLGameSaver.SaveGame(System.String,System.String)">
            <summary>
            save game into file
            </summary>
            <param name="fileName">file name</param>
            <param name="xmlData">game data</param>
        </member>
        <member name="M:XMLGameSaver.LoadGame(System.String,System.String)">
            <summary>
            load game from file
            </summary>
            <param name="fileLocation">location of file</param>
            <param name="fileName">file name</param>
            <returns>some xml</returns>
        </member>
        <member name="M:XMLGameSaver.LoadGame(System.String)">
            <summary>
            load game from file
            </summary>
            <param name="fileName">file name</param>
            <returns>a strings</returns>
        </member>
        <member name="M:XMLGameSaver.UTF8ByteArrayToString(System.Byte[])">
            <summary>
            transform a UTF8 byte array to string
            used in SerializeObject function
            </summary>
            <param name="characters">some characters</param>
            <returns>some magic</returns>
        </member>
        <member name="M:XMLGameSaver.StringToUTF8ByteArray(System.String)">
            <summary>
            transform a string to UTF8 byte array
            used in DeserializeObject function
            </summary>
            <param name="xmlString">some xml</param>
            <returns>no idea</returns>
        </member>
        <member name="T:BaseSkill">
            <summary>
            base skill class with standard definitions for certain methods
            </summary>
        </member>
        <member name="F:BaseSkill.iconTexture">
            <summary>
            Save the corresponding icon.
            </summary>
        </member>
        <member name="M:BaseSkill.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:BaseSkill.GetIconTexture">
            <summary>
            Return the corresponding icon.
            </summary>
            <returns>the texture</returns>
        </member>
        <member name="M:BaseSkill.GetNeededSkills">
            <summary>
            returns a list of skill names that are needed for this very skill to be learned
            </summary>
            <returns>list of skills</returns>
        </member>
        <member name="M:BaseSkill.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>list of items</returns>
        </member>
        <member name="M:BaseSkill.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            called when used
            </summary>
            <summary>Called when the skill is being used</summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:BaseSkill.OnUseWithoutMana(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            similar to OnUse but only called when the player has not enough mana for the skill
            when returning true, the skill will be set on cooldown BUT no mana will be drained
            this can be used to specify f.e. fallback skills (electro fist may just use fist when low on mana)
            </summary>
            <param name="by">by who</param>
            <param name="igorInstance">the igor</param>
            <param name="level">the level</param>
            <returns>true or false</returns>
        </member>
        <member name="M:BaseSkill.OnLevelChange(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill goes to another level.</summary>
            <param name="by">game object that levels the skill up</param>
            <param name="igorInstance">igor (class instance) IFF igor levels the skill</param>
            <param name="level">new level of the skill (starts at 1)</param>
            <returns>whether the level up was successful</returns>
        </member>
        <member name="M:BaseSkill.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:BaseSkill.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:BaseSkill.IsPassive">
            <summary>
            Return whether a skill is active (like attacks) or passive (walk speed, jump height, ...)
            </summary>
            <returns>Whether this skill is passive.</returns>
        </member>
        <member name="T:ElectroFistAttack">
            <summary>
            the electro fist skill
            </summary>
        </member>
        <member name="T:MeleeAttack">
            <summary>
            Igor's fist melee attack skill.
            </summary>
        </member>
        <member name="F:MeleeAttack.punchSound">
            <summary>
            sound on hitting an enemy
            </summary>
        </member>
        <member name="F:MeleeAttack.hitEffect">
            <summary>
            effect played on hit
            </summary>
        </member>
        <member name="F:MeleeAttack.initialDamage">
            <summary>
            fist damage
            </summary>
        </member>
        <member name="F:MeleeAttack.cooldown">
            <summary>
            cooldown in seconds
            </summary>
        </member>
        <member name="M:MeleeAttack.GetDamage(System.Int32)">
            <summary>
            How much damage does the skill cast?
            </summary>
            <param name="level">The level of the skill</param>
            <returns>The damage of the attack.</returns>
        </member>
        <member name="M:MeleeAttack.GetMeleeAttackSpeed(System.Int32)">
            <summary>
            How fast is the attack at given level?
            </summary>
            <param name="level">The level of the skill</param>
            <returns>The speed of the attack (>= 1)</returns>
        </member>
        <member name="F:MeleeAttack._level">
            <summary>
            Save the level to give back correct attack speed to outer world.
            </summary>
        </member>
        <member name="M:MeleeAttack.OnLevelChange(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill goes to another level.</summary>
            <param name="by">game object that levels the skill up</param>
            <param name="igorInstance">igor (class instance) IFF igor levels the skill</param>
            <param name="level">new level of the skill (starts at 1)</param>
            <returns>whether the level up was successful</returns>
        </member>
        <member name="M:MeleeAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>The skill name.</returns>
        </member>
        <member name="M:MeleeAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill is being used</summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:MeleeAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">The level of the attack</param>
            <returns>The cooldown time.</returns>
        </member>
        <member name="M:MeleeAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">The level of the skill.</param>
            <returns>The needed energy to use the skill.</returns>
        </member>
        <member name="M:MeleeAttack.AttackCooldownAnimation(CommonEntity,MeleeAttackHelper,System.Int32)">
            <summary>
            play attack and reset cooldown
            </summary>
            <param name="ce">The common entity instance.</param>
            <param name="mah">The melee attack helper component.</param>
            <param name="level">The level of this skill</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:MeleeAttack.EnemyHit(CommonEntity,CommonEntity,UnityEngine.Collider,UnityEngine.Transform,System.Single,MeleeAttackHelper)">
            <summary>
            Called by the melee attack helper when an enemy is hit.
            </summary>
            <param name="entity">The entity which casted the attack</param>
            <param name="enemy">The enemy which is hit</param>
            <param name="collider">The collider of the enemy</param>
            <param name="fistTransform">The transform of the melee attack helper component game object.</param>
            <param name="damage">The damage which should be put upon the enemy.</param>
            <param name="mah">the melee attack helper that calls this function</param>
        </member>
        <member name="P:MeleeAttack.MeleeAttackSpeed">
            <summary>
            How fast is the attack?
            </summary>
        </member>
        <member name="M:ElectroFistAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>The skill name.</returns>
        </member>
        <member name="M:ElectroFistAttack.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>The needed items to learn this skill.</returns>
        </member>
        <member name="M:ElectroFistAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">The level of the skill.</param>
            <returns>The needed energy to use the skill.</returns>
        </member>
        <member name="M:ElectroFistAttack.OnUseWithoutMana(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            similar to OnUse but only called when the player has not enough mana for the skill
            when returning true, the skill will be set on cooldown BUT no mana will be drained
            this can be used to specify f.e. fallback skills (electro fist may just use fist when low on mana)
            </summary>
            <param name="by">by who</param>
            <param name="igorInstance">the igor</param>
            <param name="level">for level</param>
            <returns>true or false</returns>
        </member>
        <member name="M:ElectroFistAttack.AttackCooldownAnimation(CommonEntity,MeleeAttackHelper,System.Int32)">
            <summary>
            play attack and reset cooldown
            </summary>
            <param name="ce">The common entity instance.</param>
            <param name="mah">The melee attack helper component.</param>
            <param name="level">The level of this skill</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:ElectroFistAttack.EnemyHit(CommonEntity,CommonEntity,UnityEngine.Collider,UnityEngine.Transform,System.Single,MeleeAttackHelper)">
            <summary>
            Called by the melee attack helper when an enemy is hit.
            </summary>
            <param name="entity">The entity which casted the attack</param>
            <param name="enemy">The enemy which is hit</param>
            <param name="collider">The collider of the enemy</param>
            <param name="fistTransform">The transform of the melee attack helper component game object.</param>
            <param name="damage">The damage which should be put upon the enemy.</param>
            <param name="mah">the melee attack helper that calls this function</param>s
        </member>
        <member name="T:HackAttack">
            <summary>
            hack attack which can overtake enemies to fight on your side (only works in syrian nuclear reactors)
            </summary>
        </member>
        <member name="F:HackAttack.hackingEffectPrefab">
            <summary>
            effect that will be attached to the hacked object
            </summary>
        </member>
        <member name="F:HackAttack.sound">
            <summary>
            The sound which should be played when firing.
            </summary>
        </member>
        <member name="F:HackAttack.duration">
            <summary>
            Time in seconds until the hacking effect is reverted.
            </summary>
        </member>
        <member name="M:HackAttack.Start">
            <summary>
            unity start
            </summary>
        </member>
        <member name="M:HackAttack.GetDuration(System.Int32)">
            <summary>
            Get the seconds until the hacking effect should be reverted.
            </summary>
            <param name="level">The level of the skill.</param>
            <returns>Time in seconds until the hacking effect is reverted.</returns>
        </member>
        <member name="M:HackAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:HackAttack.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>list of items</returns>
        </member>
        <member name="M:HackAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill is being used</summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:HackAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:HackAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:HackAttack.AttackCooldownAnimation(CommonEntity,System.Int32)">
            <summary>
            Play the animation and spawn the sphere.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">for level</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:HackAttack.RevertHackEffect(System.Single,CommonEntity,UnityEngine.GameObject)">
            <summary>
            Revert the hack effect after some time.
            </summary>
            <param name="waitDuration">The time to wait.</param>
            <param name="entity">The hacked entity.</param>
            <param name="effect">The effect object.</param>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:HackAttack.GetEnemyForHacking(CommonEntity)">
            <summary>
            looks for enemy to take over
            prefer closer enemies BUT favor enemies directly in your LOS
            </summary>
            <param name="caster">who uses the skill</param>
            <returns>common entity</returns>
        </member>
        <member name="T:HeadbangAttack">
            <summary>
            Igor's head bang
            </summary>
        </member>
        <member name="F:HeadbangAttack.hitSound">
            <summary>
            sound on hitting an enemy
            </summary>
        </member>
        <member name="F:HeadbangAttack.hitParticleEffect">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
        </member>
        <member name="M:HeadbangAttack.GetDamageForLevel(System.Int32)">
            <summary>
            the name of the function/variable represents the desired behavior and effects quite efficiently. Please read it and interpret it as you like. You will most likely get the correct interpretation.
            </summary>
            <param name="level">for level</param>
            <returns>damage for level</returns>
        </member>
        <member name="M:HeadbangAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>The skill name.</returns>
        </member>
        <member name="M:HeadbangAttack.GetNeededSkills">
            <summary>
            names of requirements
            </summary>
            <returns>The skill name</returns>
        </member>
        <member name="M:HeadbangAttack.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>The skill name</returns>
        </member>
        <member name="M:HeadbangAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill is being used</summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:HeadbangAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">The level of the attack</param>
            <returns>The cooldown time.</returns>
        </member>
        <member name="M:HeadbangAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">The level of the skill.</param>
            <returns>The needed energy to use the skill.</returns>
        </member>
        <member name="M:HeadbangAttack.AttackCooldownAnimation(Igor,System.Int32)">
            <summary>
            play attack and unlock
            </summary>
            <param name="igor">The igor instance.</param>
            <param name="level">The level of this skill</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:MeleeAttackHelper">
            <summary>
            Manages damage for melee attack
            Add the IgorPrimaryAttack prefab as child of the Igor GameObject to the bone which should damage the enemy.
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.attackDamage">
            <summary>
            Damage of the attack
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.alreadyHit">
            <summary>
            indicates whether an enemy is already hit (prevent multiple hits in one melee attack)
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.faction">
            <summary>
            indicates who's enemies to look for
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.attackSkill">
            <summary>
            The corresponding attack skill.
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.roundhouseSkill">
            <summary>
            corresponding roundhouse attack skill
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.inRoundhouse">
            <summary>
            indicates whether igor is in a roundhouse attack or not
            </summary>
        </member>
        <member name="F:MeleeAttackHelper.ce">
            <summary>
            The common entity to which this helper belongs.
            </summary>
        </member>
        <member name="M:MeleeAttackHelper.Start">
            <summary>
            deactivate collider on startup.
            </summary>
        </member>
        <member name="M:MeleeAttackHelper.OnTriggerStay(UnityEngine.Collider)">
            <summary>
            handles a collision and give the enemy damage
            </summary>
            <param name="other">some collider</param>
        </member>
        <member name="M:MeleeAttackHelper.PlaySound(UnityEngine.AudioClip)">
            <summary>
            plays a sound
            </summary>
            <param name="sound">AudioClip that should be played</param>
        </member>
        <member name="M:MeleeAttackHelper.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            executed on collision
            </summary>
            <param name="other">collider information</param>
        </member>
        <member name="T:LaserAttack">
            <summary>
            the laser attack
            </summary>
        </member>
        <member name="F:LaserAttack.projectilePrefab">
            <summary>
            The projectile we are going to instantiate.
            </summary>
        </member>
        <member name="F:LaserAttack.sound">
            <summary>
            The sound which should be played when firing.
            </summary>
        </member>
        <member name="F:LaserAttack.animationDuration">
            <summary>
            Duration of the animation.
            </summary>
        </member>
        <member name="F:LaserAttack.initialLaserDamage">
            <summary>
            Initial laser damage without skill points
            </summary>
        </member>
        <member name="M:LaserAttack.Start">
            <summary>
            unity start
            </summary>
        </member>
        <member name="M:LaserAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:LaserAttack.GetNeededSkills">
            <summary>
            mandatory skills
            </summary>
            <returns>list of skills</returns>
        </member>
        <member name="M:LaserAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            called when used
            </summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:LaserAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:LaserAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:LaserAttack.AttackCooldownAnimation(CommonEntity,System.Int32)">
            <summary>
            Play the animation and spawn projectiles.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">for level</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:LaserAttack.SpawnProjectiles(CommonEntity,System.Int32)">
            <summary>
            Spawn the projectiles.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">for level</param>
        </member>
        <member name="M:LaserAttack.SpawnProjectile(CommonEntity,System.Single,System.Single,System.Single)">
            <summary>
            Spawn a projectile with a certain /damage/. Rotate optionally by a vertical and horizontal angle.
            </summary>
            <param name="ce">common entity</param>
            <param name="damage">The damage made by this projectile.</param>
            <param name="horizontalAngle">The vertical angle.</param>
            <param name="verticalAngle">The horizontal angle.</param>
        </member>
        <member name="T:LightningAttack">
            <summary>
            Attack which selects the next enemy inside our range and attacks it.
            </summary>
        </member>
        <member name="F:LightningAttack.lightningPrefab">
            <summary>
            The lightning we are going to instantiate.
            </summary>
        </member>
        <member name="F:LightningAttack.lightningMissPrefab">
            <summary>
            The lightning we are going to instantiate when not hitting.
            </summary>
        </member>
        <member name="F:LightningAttack.sound">
            <summary>
            The sound which should be played when firing.
            </summary>
        </member>
        <member name="F:LightningAttack.animationDuration">
            <summary>
            Duration of the animation.
            </summary>
            TODO: FIXME
        </member>
        <member name="F:LightningAttack.initialDamage">
            <summary>
            Initial damage without skill points
            </summary>
        </member>
        <member name="F:LightningAttack.initialRange">
            <summary>
            The initial distance of our attack.
            </summary>
        </member>
        <member name="M:LightningAttack.GetDamage(System.Int32)">
            <summary>
            Return the damage at given level.
            </summary>
            <param name="level">The skill level.</param>
            <returns>The damage.</returns>
        </member>
        <member name="M:LightningAttack.GetRange(System.Int32)">
            <summary>
            Return the range at given level.
            </summary>
            <param name="level">The skill level.</param>
            <returns>The range.</returns>
        </member>
        <member name="M:LightningAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:LightningAttack.GetNeededSkills">
            <summary>
            returns mandatory skills
            </summary>
            <returns>the skills</returns>
        </member>
        <member name="M:LightningAttack.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>The items needed to learn this skill.</returns>
        </member>
        <member name="M:LightningAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            called when used
            </summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:LightningAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:LightningAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>some energy</returns>
        </member>
        <member name="M:LightningAttack.AttackCooldownAnimation(CommonEntity,System.Int32)">
            <summary>
            Play the animation and spawn projectiles.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">the level</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:HeadMarker">
            <summary>
            Empty class to mark the correct head transform.
            </summary>
        </member>
        <member name="T:LightningSourceMarker">
            <summary>
            Empty class to mark the correct transform for LightningAttack.
            </summary>
        </member>
        <member name="T:MicrowaveAttack">
            <summary>
            Microwave Attack which spreads like a sphere and hits everything.
            </summary>
        </member>
        <member name="F:MicrowaveAttack.microwaveSpherePrefab">
            <summary>
            The microwave sphere.
            </summary>
        </member>
        <member name="F:MicrowaveAttack.sound">
            <summary>
            The sound which should be played when firing.
            </summary>
        </member>
        <member name="F:MicrowaveAttack.initialDamage">
            <summary>
            Initial damage without skill points
            </summary>
        </member>
        <member name="F:MicrowaveAttack.initialRange">
            <summary>
            The initial range of the microwave attack.
            </summary>
        </member>
        <member name="M:MicrowaveAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>skill name</returns>
        </member>
        <member name="M:MicrowaveAttack.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>list of items</returns>
        </member>
        <member name="M:MicrowaveAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill is being used</summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:MicrowaveAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:MicrowaveAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:MicrowaveAttack.AttackCooldownAnimation(CommonEntity,System.Int32)">
            <summary>
            Play the animation and spawn the sphere.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">the level</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:PassiveBaseSkill">
            <summary>
            a base skill that contains standard implementations for passive-related skills
            </summary>
        </member>
        <member name="M:PassiveBaseSkill.IsPassive">
            <summary>
            Return whether a skill is active (like attacks) or passive (walk speed, jump height, ...)
            </summary>
            <returns>Whether this skill is passive.</returns>
        </member>
        <member name="M:PassiveBaseSkill.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:PassiveBaseSkill.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="T:PassiveIgorSkill">
            <summary>
            The class for all passive skills.
            </summary>
        </member>
        <member name="F:PassiveIgorSkill.skillName">
            <summary>
            The name of this skill.
            </summary>
        </member>
        <member name="F:PassiveIgorSkill.propertyName">
            <summary>
            The name of the corresponding property inside Igor. Derived from skillName.
            </summary>
        </member>
        <member name="F:PassiveIgorSkill.initialPropertyName">
            <summary>
            The name of the corresponding initial property inside Igor. Derived from skillName.
            </summary>
        </member>
        <member name="F:PassiveIgorSkill.factor">
            <summary>
            Scaling factor for all passive skills.
            </summary>
        </member>
        <member name="M:PassiveIgorSkill.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>the name</returns>
        </member>
        <member name="M:PassiveIgorSkill.Awake">
            <summary>
            Called when being instantiated.
            </summary>
        </member>
        <member name="M:PassiveIgorSkill.OnLevelChange(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>Called when the skill goes to another level.</summary>
            <param name="by">game object that levels the skill up</param>
            <param name="igorInstance">igor (class instance) IFF igor levels the skill</param>
            <param name="level">new level of the skill (starts at 1)</param>
            <returns>whether the level up was successful</returns>
        </member>
        <member name="M:PassiveIgorSkill.GetNeededSkills">
            <summary>
            other skills that are needed to learn a certain skill
            </summary>
            <returns>An array of the needed skill to get this skill.</returns>
        </member>
        <member name="T:PrismAttack">
            <summary>
            the mighty prism, super laser attack
            </summary>
        </member>
        <member name="M:PrismAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:PrismAttack.GetNeededSkills">
            <summary>
            parent skills
            </summary>
            <returns>some skills</returns>
        </member>
        <member name="M:PrismAttack.GetNeededItems">
            <summary>
            some items
            </summary>
            <returns>needed items</returns>
        </member>
        <member name="M:PrismAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for which level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:PrismAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            called when used
            </summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="F:PrismAttack.attackLevels">
            <summary>
            The attack types per level.
            </summary>
        </member>
        <member name="F:PrismAttack.attackProjectiles">
            <summary>
            The number of projectiles per attack level.
            </summary>
        </member>
        <member name="M:PrismAttack.SpawnProjectiles(CommonEntity,System.Int32)">
            <summary>
            Spawn the projectiles.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">for what level</param>
        </member>
        <member name="T:PrismAttack.LaserAttack">
            <summary>
            Define how the laser attack should work.
            </summary>
        </member>
        <member name="T:RoundhouseAttack">
            <summary>
            Igor's roundhouse attack
            </summary>
        </member>
        <member name="F:RoundhouseAttack.sound">
            <summary>
            The sound which should be played when firing.
            </summary>
        </member>
        <member name="F:RoundhouseAttack.animationDuration">
            <summary>
            Duration of the animation.
            </summary>
        </member>
        <member name="F:RoundhouseAttack.initialDamage">
            <summary>
            Initial damage without skill points
            </summary>
        </member>
        <member name="M:RoundhouseAttack.GetName">
            <summary>
            return the skill name.
            </summary>
            <returns>a name</returns>
        </member>
        <member name="M:RoundhouseAttack.GetNeededSkills">
            <summary>
            returns an array with mandatory skills
            </summary>
            <returns>mandatory skills</returns>
        </member>
        <member name="M:RoundhouseAttack.GetNeededItems">
            <summary>
            special items that are needed to learn a certain skill
            </summary>
            <returns>needed items</returns>
        </member>
        <member name="M:RoundhouseAttack.OnUse(UnityEngine.GameObject,Igor,System.Int32)">
            <summary>
            called when a skill is used
            </summary>
            <param name="by">game object that uses the skill</param>
            <param name="igorInstance">igor (class instance) IFF igor uses the skill</param>
            <param name="level">level of the skill (starts at 1)</param>
            <returns>whether the usage was successful</returns>
        </member>
        <member name="M:RoundhouseAttack.GetCooldown(System.Int32)">
            <summary>
            returns the skill cooldown in seconds for a specified level
            </summary>
            <param name="level">for level</param>
            <returns>the cooldown</returns>
        </member>
        <member name="M:RoundhouseAttack.GetNeededEnergy(System.Int32)">
            <summary>
            returns the needed energy for a specified level
            the skill will not be executed if the energy is lower
            </summary>
            <param name="level">for level</param>
            <returns>the energy</returns>
        </member>
        <member name="M:RoundhouseAttack.GetDamage(System.Int32)">
            <summary>
            How much damage does the skill cast?
            </summary>
            <param name="level">The level of the skill</param>
            <returns>The damage of the attack.</returns>
        </member>
        <member name="M:RoundhouseAttack.AttackCooldownAnimation(CommonEntity,System.Int32)">
            <summary>
            Play the animation and spawn projectiles.
            </summary>
            <param name="ce">common entity</param>
            <param name="level">the level</param>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="M:RoundhouseAttack.EnemyHit(CommonEntity,CommonEntity,UnityEngine.Collider,UnityEngine.Transform,System.Single,MeleeAttackHelper)">
            <summary>
            Called by the melee attack helper when an enemy is hit.
            </summary>
            <param name="entity">The entity which casted the attack</param>
            <param name="enemy">The enemy which is hit</param>
            <param name="collider">The collider of the enemy</param>
            <param name="fistTransform">The transform of the melee attack helper component game object.</param>
            <param name="damage">The damage which should be put upon the enemy.</param>
            <param name="mah">the melee attack helper that calls this function</param>
        </member>
        <member name="T:Skills">
            <summary>
            system for handling skills, learning and leveling
            </summary>
        </member>
        <member name="F:Skills.SkillNames">
            <summary>
            all skills that are available to Igor
            </summary>
        </member>
        <member name="F:Skills.skills">
            <summary>
            keeps instances of the skill prefabs
            </summary>
        </member>
        <member name="M:Skills.SkillsClear">
            <summary>
            clears the skill list
            this also resets all of the levels etc.
            </summary>
        </member>
        <member name="M:Skills.InstantiateSkills">
            <summary>
            instantiates all of the skill prefabs
            </summary>
            <returns>whether the skills have been instantiated - if false, they were kept</returns>
        </member>
        <member name="M:Skills.GetSkill(System.String)">
            <summary>
            returns a skill (if existing) with the specified display name (which is not the name of the prefab)
            </summary>
            <param name="displayName">display name of the skill</param>
            <returns>see above</returns>
        </member>
        <member name="M:Skills.GetSkills">
            <summary>
            returns all possible skills that can be learned by Igor
            </summary>
            <returns>yeah, see above</returns>
        </member>
        <member name="M:Skills.KnowsSkill(System.String)">
            <summary>
            whether Igor currently knows a certain skill
            </summary>
            <param name="name">name of skill</param>
            <returns>I just said that</returns>
        </member>
        <member name="M:Skills.LevelUpSkill(System.String)">
            <summary>
            increases the level of a skill
            </summary>
            <param name="name">which skill</param>
            <returns>whether successful</returns>
        </member>
        <member name="M:Skills.SetSkillLevel(System.String,System.Int32)">
            <summary>
            sets the level of a skill
            </summary>
            <param name="name">which skill</param>
            <param name="level">to which level</param>
        </member>
        <member name="T:Skills.SkillData">
            <summary>
            keeps track of skill stuff
            </summary>
        </member>
        <member name="F:Skills.SkillData.skill">
            <summary>
            skill of the skill data
            </summary>
        </member>
        <member name="F:Skills.SkillData.level">
            <summary>
            level of the skill
            </summary>
        </member>
        <member name="M:Skills.SkillData.#ctor(ISkill,System.Int32)">
            <summary>
            constructs something
            </summary>
            <param name="_skill">to skill</param>
            <param name="_level">to level</param>
        </member>
        <member name="M:Skills.SkillData.IsRelated(Skills.SkillData)">
            <summary>
            returns whether two skills are related (parent-child-relationship)
            </summary>
            <param name="otherSkillData">other skill</param>
            <returns>whether related</returns>
        </member>
        <member name="M:Skills.SkillData.IsChildOf(Skills.SkillData)">
            <summary>
            in a skill tree sense
            </summary>
            <param name="otherSkillData">other skill</param>
            <returns>whether child</returns>
        </member>
        <member name="M:Skills.SkillData.IsParentOf(Skills.SkillData)">
            <summary>
            see above
            </summary>
            <param name="otherSkillData">other skill</param>
            <returns>whether parent</returns>
        </member>
        <member name="T:DestructIgor">
            <summary>
            script for prefab to prevent having Igor in some scenes
            </summary>
        </member>
        <member name="M:DestructIgor.Start">
            <summary>
            destroys an igor if there is one
            </summary>
        </member>
        <member name="T:DontDestruct">
            <summary>
            script that can be added to an object to prevent it from being destroyed when a level loads
            </summary>
        </member>
        <member name="M:DontDestruct.Start">
            <summary>
            keeps game object from destruction when changing scene
            </summary>
        </member>
        <member name="T:SceneLoader">
            <summary>
            Loads a scene on the point of the current game object
            </summary>
        </member>
        <member name="F:SceneLoader.sceneName">
            <summary>
            name of the scene that should be loaded
            </summary>
        </member>
        <member name="F:SceneLoader.otherTriggable">
            <summary>
            possible trigger that should be called after loading
            </summary>
        </member>
        <member name="F:SceneLoader.triggered">
            <summary>
            indicates whether the loader has been already triggered or not
            </summary>
        </member>
        <member name="F:SceneLoader.delay">
            <summary>
            seconds to wait until loading
            </summary>
        </member>
        <member name="M:SceneLoader.Start">
            <summary>
            Called by Unity
            </summary>
        </member>
        <member name="M:SceneLoader.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            called by the trigger when it's activated
            </summary>
            <param name="by">by who</param>
            <param name="isTriggered">whether triggered</param>
        </member>
        <member name="M:SceneLoader.Load">
            <summary>
            a loading coroutine
            </summary>
            <returns>An enumerator needed for yielding, just throw it away</returns>
        </member>
        <member name="T:SelfDestructor">
            <summary>
            destroys the own game object when triggered
            </summary>
        </member>
        <member name="M:SelfDestructor.OnTrigger(UnityEngine.GameObject,System.Boolean)">
            <summary>
            should be called when the object "by" wants to use the trigger (via a usage action)
            </summary>
            <param name="by">by who</param>
            <param name="isTriggered">whether triggered</param>
        </member>
        <member name="T:SpawnPoint">
            <summary>
            manages spawn point
            </summary>
        </member>
        <member name="F:SpawnPoint.igorPrefab">
            <summary>
            Igor Prefab that should be instantiated
            </summary>
        </member>
        <member name="M:SpawnPoint.Start">
            <summary>
            Unity start
            </summary>
        </member>
        <member name="M:SpawnPoint.SpawnIgor">
            <summary>
            spawns an igor given in the prefab
            </summary>
            <returns>the igor instance</returns>
        </member>
        <member name="T:Waypoint">
            <summary>
            Waypoint script
            </summary>
        </member>
        <member name="M:Waypoint.Start">
            <summary>
            just destruct the renderer
            </summary>
        </member>
        <member name="T:SwitchPlatform">
            <summary>
            Switch platform used in puzzle
            </summary>
        </member>
        <member name="F:SwitchPlatform.platform1">
            <summary>
            some platform
            </summary>
        </member>
        <member name="F:SwitchPlatform.platform">
            <summary>
            the platform
            </summary>
        </member>
        <member name="M:SwitchPlatform.Start">
            <summary>
            Unity Start
            </summary>
        </member>
        <member name="M:SwitchPlatform.OnCollisionEnter(UnityEngine.Collision)">
            <summary>
            Unity Callback
            </summary>
            <param name="collision">some collision</param>
        </member>
        <member name="T:TestCutscene">
            <summary>
            a random cutscene
            </summary>
        </member>
        <member name="F:TestCutscene.toAnimate">
            <summary>
            some object
            </summary>
        </member>
        <member name="M:TestCutscene.Script">
            <summary>
            the script
            </summary>
        </member>
        <member name="T:Mine">
            <summary>
            this is pretty dangerous but the numbers tell you how many mines are around, ok
            </summary>
        </member>
        <member name="F:Mine.faction">
            <summary>
            the faction the mine belongs to. Will not damage friends.
            </summary>
        </member>
        <member name="F:Mine.explosionEffectPrefab">
            <summary>
            played when BLOWING THE F UP
            </summary>
        </member>
        <member name="F:Mine.damage">
            <summary>
            damage dealt to anyone in range
            </summary>
        </member>
        <member name="F:Mine.explosionAudioClip">
            <summary>
            sound played when exploding
            </summary>
        </member>
        <member name="M:Mine.OnCollisionEnter(UnityEngine.Collision)">
            <summary>
            Unity Callback
            </summary>
            <param name="collision">a collision</param>
        </member>
    </members>
</doc>
